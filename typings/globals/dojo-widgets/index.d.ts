// Generated by typings
// Source: node_modules/dojo-widgets/dist/umd/dojo-widgets.d.ts
declare module 'dojo-widgets/util/lang' {
	import { List } from 'immutable/immutable';
	export type Position = number | 'first' | 'last' | 'before' | 'after';
	export function insertInList<T>(list: List<T>, item: T, position: Position, reference?: T): List<T>;
	export function insertInArray<T>(array: T[], item: T, position: Position, reference?: T): T[];
	/**
	 * Internal function to convert a state value to a string
	 * @param value The value to be converted
	 */
	export function valueToString(value: any): string;
	/**
	 * Internal function to convert a string to the likely more complex value stored in
	 * state
	 * @param str The string to convert to a state value
	 */
	export function stringToValue(str: string): any;

}
declare module 'dojo-widgets/mixins/createRenderable' {
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	import { ParentMixin } from 'dojo-widgets/mixins/createParentMixin';
	export interface RenderFunction {
	    (): VNode;
	}
	export interface RenderableOptions {
	    /**
	     * A render function to be used.
	     */
	    render?: RenderFunction;
	    tagName?: string;
	    parent?: ParentMixin<any>;
	}
	export interface RenderableMixin {
	    /**
	     * Takes no arguments and returns a VNode
	     */
	    render(): VNode;
	    /**
	     * The tag name to be used
	     */
	    tagName: string;
	    parent?: ParentMixin<Renderable>;
	}
	export type Renderable = Destroyable & RenderableMixin;
	export interface RenderableFactory extends ComposeFactory<Renderable, RenderableOptions> {
	}
	export function isRenderable(value: any): value is Renderable; const createRenderable: RenderableFactory;
	export default createRenderable;

}
declare module 'dojo-widgets/mixins/createParentMixin' {
	import { List } from 'immutable/immutable';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	import { Handle } from 'dojo-core/interfaces';
	import { Position } from 'dojo-widgets/util/lang';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	export interface ParentMixinOptions<C extends Child> {
	    /**
	     * Children that are owned by the parent on creation
	     */
	    children?: C[];
	}
	export type Child = Renderable;
	export interface Parent<C extends Child> {
	    /**
	     * An immutable list of children for this parent
	     */
	    children: List<C>;
	    /**
	     * Append a child (or children) to the parent
	     * @param child The child to append
	     */
	    append(child: C): Handle;
	    /**
	     * Append a child (or children) to the parent
	     * @param children The children to append
	     */
	    append(children: C[]): Handle;
	    /**
	     * Remove all children (but don't destory them)
	     */
	    clear(): void;
	    /**
	     * Insert a child in a specific position, providing the reference if required
	     * @param child The child to insert
	     * @param position The position to insert the child
	     * @param reference The referencable child, if required
	     */
	    insert(child: C, position: Position, reference?: C): Handle;
	}
	export type ParentMixin<C extends Child> = Parent<C> & Destroyable;
	export interface ParentMixinFactory extends ComposeFactory<ParentMixin<Child>, ParentMixinOptions<Child>> {
	} const createParentMixin: ParentMixinFactory;
	export default createParentMixin;

}
declare module 'dojo-widgets/mixins/createVNodeEvented' {
	import { Handle } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Evented, EventedOptions, EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';
	export interface VNodeListeners {
	    [on: string]: (ev?: TargettedEventObject) => boolean | void;
	    ontouchcancel?(ev?: TouchEvent): boolean | void;
	    ontouchend?(ev?: TouchEvent): boolean | void;
	    ontouchmove?(ev?: TouchEvent): boolean | void;
	    ontouchstart?(ev?: TouchEvent): boolean | void;
	    onblur?(ev?: FocusEvent): boolean | void;
	    onchange?(ev?: Event): boolean | void;
	    onclick?(ev?: MouseEvent): boolean | void;
	    ondblclick?(ev?: MouseEvent): boolean | void;
	    onfocus?(ev?: FocusEvent): boolean | void;
	    oninput?(ev?: Event): boolean | void;
	    onkeydown?(ev?: KeyboardEvent): boolean | void;
	    onkeypress?(ev?: KeyboardEvent): boolean | void;
	    onkeyup?(ev?: KeyboardEvent): boolean | void;
	    onload?(ev?: Event): boolean | void;
	    onmousedown?(ev?: MouseEvent): boolean | void;
	    onmouseenter?(ev?: MouseEvent): boolean | void;
	    onmouseleave?(ev?: MouseEvent): boolean | void;
	    onmousemove?(ev?: MouseEvent): boolean | void;
	    onmouseout?(ev?: MouseEvent): boolean | void;
	    onmouseover?(ev?: MouseEvent): boolean | void;
	    onmouseup?(ev?: MouseEvent): boolean | void;
	    onmousewheel?(ev?: MouseWheelEvent): boolean | void;
	    onscroll?(ev?: UIEvent): boolean | void;
	    onsubmit?(ev?: Event): boolean | void;
	}
	export interface VNodeEventedMixin {
	    /**
	     * A map of listeners that are exposed for use by the virutal DOM
	     */
	    listeners: VNodeListeners;
	}
	export interface VNodeEventedOverrides {
	    on(type: 'touchcancel', listener: EventedListener<TouchEvent>): Handle;
	    on(type: 'touchend', listener: EventedListener<TouchEvent>): Handle;
	    on(type: 'touchmove', listener: EventedListener<TouchEvent>): Handle;
	    on(type: 'blur', listener: EventedListener<FocusEvent>): Handle;
	    on(type: 'change', listener: EventedListener<Event>): Handle;
	    on(type: 'click', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'dblclick', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'focus', listener: EventedListener<FocusEvent>): Handle;
	    on(type: 'input', listener: EventedListener<Event>): Handle;
	    on(type: 'keydown', listener: EventedListener<KeyboardEvent>): Handle;
	    on(type: 'keypress', listener: EventedListener<KeyboardEvent>): Handle;
	    on(type: 'keyup', listener: EventedListener<KeyboardEvent>): Handle;
	    on(type: 'load', listener: EventedListener<Event>): Handle;
	    on(type: 'mousedown', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mouseenter', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mouseleave', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mousemove', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mouseout', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mouseover', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mouseup', listener: EventedListener<MouseEvent>): Handle;
	    on(type: 'mousewheel', listener: EventedListener<MouseWheelEvent>): Handle;
	    on(type: 'scroll', listener: EventedListener<UIEvent>): Handle;
	    on(type: 'submit', listener: EventedListener<Event>): Handle;
	    /**
	     * Add a listener to an event by type
	     * @param type The type of event to listen for
	     * @param listener The event listener to attach
	     */
	    on(type: string, listener: EventedListener<TargettedEventObject>): Handle;
	}
	export type VNodeEvented = Evented & VNodeEventedMixin & VNodeEventedOverrides;
	export interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, EventedOptions> {
	} const createVNodeEvented: VNodeEventedFactory;
	export default createVNodeEvented;

}
declare module 'dojo-widgets/mixins/createCachedRenderMixin' {
	import { VNode, VNodeProperties } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { State, Stateful, StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { ParentMixin, Child } from 'dojo-widgets/mixins/createParentMixin';
	import { Renderable } from 'dojo-widgets/mixins/createRenderable';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	export type StylesHash = {
	    [style: string]: string;
	};
	export interface CachedRenderState extends State {
	    /**
	     * The ID of this widget
	     */
	    id?: string;
	    /**
	     * Any label text for this widget
	     */
	    label?: string;
	    /**
	     * Any classes to set at construction to the VNode
	     */
	    classes?: string[];
	    /**
	     * Any styles to set at startup to the VNode
	     */
	    styles?: StylesHash;
	}
	export type CachedRenderParent = ParentMixin<Child> & {
	    /**
	     * Invalidate the widget so that it will recalculate on its next render
	     */
	    invalidate(): void;
	};
	export interface CachedRender {
	    /**
	     * Returns the node attribute properties to be used by a render function
	     * @param overrides Any optional overrides of properties
	     */
	    getNodeAttributes(overrides?: VNodeProperties): VNodeProperties;
	    /**
	     * Returns any children VNodes that are part of the widget
	     */
	    getChildrenNodes(): (VNode | string)[];
	    /**
	     * Invalidate the widget so that it will recalculate on its next render
	     */
	    invalidate(): void;
	    /**
	     * An array of strings that represent classes to be set on the widget.  If classes are present in the state, getting and
	     * setting classes is done on the state, otherwise they are shadowed on the instance.
	     */
	    classes: string[];
	    render(): VNode;
	    /**
	     * A has of styles that should be applied to root VNode of the widget.  If styles are present in the state, getting and
	     * setting classes is done on the state, otherwiser they are shadowed on the instance.
	     */
	    styles: StylesHash;
	}
	export interface CachedRenderOverrides {
	    /**
	     * The parent of the widget
	     */
	    parent?: CachedRenderParent;
	}
	export type CachedRenderMixin<S extends CachedRenderState> = Stateful<S> & Renderable & CachedRender & VNodeEvented & CachedRenderOverrides;
	export interface CachedRenderFactory extends ComposeFactory<CachedRenderMixin<CachedRenderState>, StatefulOptions<CachedRenderState>> {
	} const createCachedRenderMixin: CachedRenderFactory;
	export default createCachedRenderMixin;

}
declare module 'dojo-widgets/createWidget' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventedOptions } from 'dojo-compose/mixins/createEvented';
	import { StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { RenderableOptions } from 'dojo-widgets/mixins/createRenderable';
	export interface WidgetState extends CachedRenderState {
	}
	export interface WidgetOptions<S extends WidgetState> extends StatefulOptions<S>, EventedOptions, RenderableOptions {
	}
	export type Widget<S extends WidgetState> = CachedRenderMixin<S>;
	export interface WidgetFactory extends ComposeFactory<Widget<WidgetState>, WidgetOptions<WidgetState>> {
	    <S extends WidgetState>(options?: WidgetOptions<S>): Widget<S>;
	} const createWidget: WidgetFactory;
	export default createWidget;

}
declare module 'dojo-widgets/util/createCancelableEvent' {
	export interface CancelableEvent<T extends string, U> {
	    /**
	     * The type of the event
	     * TODO: Mark as readonly in TS2
	     */
	    type: T;
	    /**
	     * The target for the event
	     * TODO: Mark as readonly in TS2
	     */
	    target: U;
	    /**
	     * Can the event be canceled?
	     * TODO: Mark as readonly in TS2
	     */
	    cancelable: boolean;
	    /**
	     * Was the event canceled?
	     * TODO: Mark as readonly in TS2
	     */
	    defaultPrevented: boolean;
	    /**
	     * Cancel the event
	     * TODO: Mark as readonly in TS2
	     */
	    preventDefault(): void;
	} function createCancelableEvent<T extends string, U>(options: {
	    type: T;
	    target: U;
	}): CancelableEvent<T, U>;
	export default createCancelableEvent;

}
declare module 'dojo-widgets/mixins/createFormFieldMixin' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';
	import { Stateful, State, StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { Handle } from 'dojo-core/interfaces';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { CancelableEvent } from 'dojo-widgets/util/createCancelableEvent';
	export interface FormFieldMixinOptions<V, S extends FormFieldMixinState<V>> extends StatefulOptions<S> {
	    type?: string;
	    value?: V;
	}
	export interface FormFieldMixinState<V> extends State, CachedRenderState {
	    /**
	     * The form widget's name
	     */
	    name?: string;
	    /**
	     * The current value
	     */
	    value?: V;
	    /**
	     * Whether the field is currently disabled or not
	     */
	    disabled?: boolean;
	}
	export interface ValueChangeEvent<V> extends CancelableEvent<'valuechange', FormFieldMixin<V, FormFieldMixinState<V>>> {
	    type: 'valuechange';
	    oldValue: string;
	    value: string;
	}
	export interface FormField<V> {
	    /**
	     * The HTML type for this widget
	     */
	    type?: string;
	    /**
	     * The string value of this form widget, which is read from the widget state
	     */
	    value?: string;
	    on?(type: 'valuechange', listener: EventedListener<ValueChangeEvent<V>>): Handle;
	    on?(type: string, listener: EventedListener<TargettedEventObject>): Handle;
	}
	export type FormFieldMixin<V, S extends FormFieldMixinState<V>> = FormField<V> & Stateful<S> & CachedRenderMixin<S>;
	export interface FormMixinFactory extends ComposeFactory<FormFieldMixin<any, FormFieldMixinState<any>>, FormFieldMixinOptions<any, FormFieldMixinState<any>>> {
	    <V>(options?: FormFieldMixinOptions<V, FormFieldMixinState<V>>): FormFieldMixin<V, FormFieldMixinState<V>>;
	} const createFormMixin: FormMixinFactory;
	export default createFormMixin;

}
declare module 'dojo-widgets/createButton' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface ButtonState extends WidgetState, FormFieldMixinState<string> {
	}
	export interface ButtonOptions extends WidgetOptions<ButtonState>, FormFieldMixinOptions<any, ButtonState> {
	}
	export type Button = Widget<ButtonState> & FormFieldMixin<string, ButtonState>;
	export interface ButtonFactory extends ComposeFactory<Button, ButtonOptions> {
	} const createButton: ButtonFactory;
	export default createButton;

}
declare module 'dojo-widgets/mixins/createRenderableChildrenMixin' {
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	export interface RenderableChildrenOptions {
	}
	export interface RenderableChildrenMixin {
	    /**
	     * Return an array of VNodes/strings the represent the rendered results of the children of this instance
	     */
	    getChildrenNodes(): (VNode | string)[];
	}
	export interface RenderableChildrenFactory extends ComposeFactory<RenderableChildrenMixin, RenderableChildrenOptions> {
	} const createRenderableChildrenMixin: RenderableChildrenFactory;
	export default createRenderableChildrenMixin;

}
declare module 'dojo-widgets/createContainer' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ParentMixin, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface ContainerOptions extends WidgetOptions<WidgetState> {
	}
	export type Container = Widget<WidgetState> & ParentMixin<Child>;
	export interface ContainerFactory extends ComposeFactory<Container, ContainerOptions> {
	} const createContainer: ContainerFactory;
	export default createContainer;

}
declare module 'dojo-widgets/createDijit' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	import { Evented } from 'dojo-compose/mixins/createEvented';
	import { Stateful, State, StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { Renderable, RenderableOptions } from 'dojo-widgets/mixins/createRenderable';
	/**
	 * The minimal API that is needed for Dojo 2 widgets to manage Dojo 1 Dijits
	 */
	export interface DijitWidget {
	    /**
	     * pointer to original DOM node
	     */
	    srcNodeRef: HTMLElement;
	    /**
	     * This is our visible representation of the widget! Other DOM
	     * Nodes may by assigned to other properties, usually through the
	     * template system's data-dojo-attach-point syntax, but the domNode
	     * property is the canonical "top level" node in widget UI.
	     */
	    domNode: HTMLElement;
	    /**
	     * Processing after the DOM fragment is added to the document
	     */
	    startup(): void;
	    /**
	     * Destroy this class, releasing any resources registered via own().
	     */
	    destroy(preserveDom?: boolean): void;
	}
	/**
	 * The parameters that are passed to the Dijit constructor
	 */
	export interface DijitWidgetParams {
	    [param: string]: any;
	}
	/**
	 * A generic constructor for Dijits
	 */
	export interface DijitWidgetConstructor<D extends DijitWidget> {
	    new (params: DijitWidgetParams, srcNodeRef: string | Node): D;
	}
	export interface DijitOptions<D extends DijitWidget> extends RenderableOptions, StatefulOptions<DijitState<D>> {
	    /**
	     * An object of parameters to pass to the wrapped Dijit constructor
	     */
	    params?: DijitWidgetParams;
	    /**
	     * The Dijit constructor (or a MID that resolves to the Dijit constructor)
	     */
	    Ctor?: DijitWidgetConstructor<D> | string;
	}
	export interface DijitState<D extends DijitWidget> extends State {
	    Ctor?: string;
	    params?: DijitWidgetParams;
	}
	export interface DijitMixin<D extends DijitWidget> {
	    /**
	     * Returns the instantiated Dijit or undefined
	     *
	     * TODO: Mark as readonly in TS 2.0
	     */
	    dijit: D;
	    /**
	     * The constructor for the Dijit
	     *
	     * TODO: Mark as readonly in TS 2.0
	     */
	    Ctor: DijitWidgetConstructor<D> | string;
	    /**
	     * The parameters to pass the Dijit widget constructor
	     *
	     * TODO: Mark as readonly in TS 2.0
	     */
	    params: DijitWidgetParams;
	}
	export type Dijit<D extends DijitWidget> = Renderable & Stateful<DijitState<D>> & DijitMixin<D> & Destroyable & Evented;
	export interface DijitFactory extends ComposeFactory<Dijit<DijitWidget>, DijitOptions<DijitWidget>> {
	    /**
	     * Create a new instance of a widget which wraps a Dijit
	     */
	    <D extends DijitWidget>(options?: DijitOptions<D>): Dijit<D>;
	} const createDijit: DijitFactory;
	export default createDijit;

}
declare module 'dojo-widgets/createLayoutContainer' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface LayoutContainerOptions extends WidgetOptions<WidgetState>, ParentMixinOptions<Child> {
	}
	export type LayoutContainer = Widget<WidgetState> & ParentMixin<Child>;
	export interface LayoutContainerFactory extends ComposeFactory<LayoutContainer, LayoutContainerOptions> {
	} const createContainer: LayoutContainerFactory;
	export default createContainer;

}
declare module 'dojo-widgets/mixins/createListMixin' {
	import { VNode } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Stateful, StatefulOptions, State } from 'dojo-compose/mixins/createStateful';
	export interface ListStateItem {
	    [property: string]: any;
	    id: string | number;
	    label: string;
	}
	export interface ListMixinState<I extends ListStateItem> extends State {
	    /**
	     * Any items that are to be rendered by the list
	     */
	    items?: I[];
	}
	export interface TagNames {
	    /**
	     * The tag name for the list item
	     */
	    list: string;
	    /**
	     * The tag name for the list items
	     */
	    item: string;
	}
	export interface List {
	    /**
	     * A map of tag names to use with the list items
	     */
	    tagNames: TagNames;
	    /**
	     * Return an array of VNodes/strings the represent the rendered results of the list of this instance
	     */
	    getChildrenNodes(): (VNode | string)[];
	}
	/**
	 * A mixin that provides the functionality to render a list of items that are in its state
	 */
	export type ListMixin = List & Stateful<ListMixinState<ListStateItem>>;
	export interface ListMixinFactory extends ComposeFactory<ListMixin, StatefulOptions<ListMixinState<ListStateItem>>> {
	    <I extends ListStateItem>(options?: StatefulOptions<ListMixinState<I>>): List;
	} const createListMixin: ListMixinFactory;
	export default createListMixin;

}
declare module 'dojo-widgets/createList' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ListMixin, ListMixinState, ListStateItem } from 'dojo-widgets/mixins/createListMixin';
	export interface ListState<I extends ListStateItem> extends WidgetState, ListMixinState<I> {
	}
	export type List<I extends ListStateItem> = Widget<ListState<I>> & ListMixin;
	export interface ListFactory extends ComposeFactory<List<ListStateItem>, WidgetOptions<ListState<ListStateItem>>> {
	    <I extends ListStateItem>(options?: WidgetOptions<ListState<I>>): List<I>;
	} const createList: ListFactory;
	export default createList;

}
declare module 'dojo-widgets/mixins/createCloseableMixin' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';
	import { Stateful, State, StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { Handle } from 'dojo-core/interfaces';
	import Promise from 'dojo-core/Promise';
	import { CancelableEvent } from 'dojo-widgets/util/createCancelableEvent';
	export interface CloseableState extends State {
	    /**
	     * Determines if the widget is closeable or not
	     */
	    closeable?: boolean;
	}
	export interface CloseEvent extends CancelableEvent<'close', CloseableMixin<CloseableState>> {
	}
	export interface Closeable {
	    /**
	     * Attempt to close the widget
	     */
	    close(): Promise<boolean>;
	    on(type: 'close', listener: EventedListener<CloseEvent>): Handle;
	    on(type: string, listener: EventedListener<TargettedEventObject>): Handle;
	}
	export type CloseableMixin<S extends CloseableState> = Stateful<S> & Closeable;
	export interface CloseableMixinFactory extends ComposeFactory<CloseableMixin<CloseableState>, StatefulOptions<CloseableState>> {
	} const createCloseableMixin: CloseableMixinFactory;
	export default createCloseableMixin;

}
declare module 'dojo-widgets/createPanel' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { Closeable, CloseableState } from 'dojo-widgets/mixins/createCloseableMixin';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface PanelState extends WidgetState, CloseableState {
	    label?: string;
	}
	export interface PanelOptions extends WidgetOptions<PanelState>, ParentMixinOptions<Child> {
	}
	export type Panel = Widget<PanelState> & Closeable & ParentMixin<Child>;
	export interface PanelFactory extends ComposeFactory<Panel, PanelOptions> {
	} const createPanel: PanelFactory;
	export default createPanel;

}
declare module 'dojo-widgets/projector' {
	import 'dojo-widgets/util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min';
	import { Projector as MaquetteProjector, VNode, VNodeProperties } from 'maquette/maquette';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { EventedOptions } from 'dojo-compose/mixins/createEvented';
	import { Handle } from 'dojo-core/interfaces';
	import { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface ProjectorOptions extends ParentMixinOptions<Child>, EventedOptions {
	    /**
	     * The root element for the projector
	     */
	    root?: Element;
	    /**
	     * If `true`, automatically attach to the DOM during creation
	     */
	    autoAttach?: boolean;
	    /**
	     * If `true`, append instead of merge when attaching to the projector to the DOM
	     *
	     * Only applies if `autoAttach` is `true`
	     */
	    append?: boolean;
	}
	export interface ProjectorMixin {
	    /**
	     * Get the projector's VNode attributes
	     */
	    getNodeAttributes(overrides?: VNodeProperties): VNodeProperties;
	    /**
	     * Returns a VNode which represents the DOM for the projector
	     */
	    render(): VNode;
	    /**
	     * Attach the projector to the DOM and return a handle to detach it.
	     * @param append If `true`, it will append to the root instead of the default of merging
	     * @param tagName If `append` is `true` then `tagName` will be used to determine what tag name
	     *                is used to append to the root element. Defaults to `div`.
	     */
	    attach(append?: boolean, tagName?: string): Handle;
	    /**
	     * Inform the projector that it is in a dirty state and should re-render.  Calling event handles will automatically
	     * schedule a re-render.
	     */
	    invalidate(): void;
	    /**
	     * If unattached, set the root element for the projector.
	     * @param root The Element that should serve as the root for the projector
	     */
	    setRoot(root: Element): void;
	    /**
	     * The native maquette Projector that is being managed
	     */
	    projector: MaquetteProjector;
	    /**
	     * The root of the projector
	     */
	    root: Element;
	    /**
	     * An array of classes that should be applied to the root of the projector
	     */
	    classes?: string[];
	    /**
	     * A hash of inline styles that should be applied to the root of the projector
	     */
	    styles?: {
	        [style: string]: string;
	    };
	    /**
	     * A reference to the document that the projector is attached to
	     */
	    document: Document;
	    /**
	     * The current state of the projector
	     */
	    state: ProjectorState;
	}
	export type Projector = VNodeEvented & ParentMixin<Child> & ProjectorMixin;
	export interface ProjectorFactory extends ComposeFactory<Projector, ProjectorOptions> {
	}
	export enum ProjectorState {
	    Attached = 1,
	    Detached = 2,
	}
	export const createProjector: ProjectorFactory; const defaultProjector: Projector;
	export default defaultProjector;

}
declare module 'dojo-widgets/createResizePanel' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface ResizePanelState extends WidgetState {
	    width?: string;
	}
	export interface ResizePanelOptions extends WidgetOptions<ResizePanelState>, ParentMixinOptions<Child> {
	}
	export interface ResizePanelMixin {
	    tagNames: {
	        handle: string;
	    };
	    width: string;
	}
	export type ResizePanel = Widget<ResizePanelState> & ParentMixin<Child> & Destroyable & ResizePanelMixin;
	export interface ResizePanelFactory extends ComposeFactory<ResizePanel, ResizePanelOptions> {
	} const createResizePanel: ResizePanelFactory;
	export default createResizePanel;

}
declare module 'dojo-widgets/mixins/createTabbedMixin' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	import { StatefulOptions } from 'dojo-compose/mixins/createStateful';
	import { List } from 'immutable/immutable';
	import { CachedRenderMixin, CachedRenderState } from 'dojo-widgets/mixins/createCachedRenderMixin';
	import { CloseableMixin, CloseableState } from 'dojo-widgets/mixins/createCloseableMixin';
	import { ParentMixin, ParentMixinOptions, Child } from 'dojo-widgets/mixins/createParentMixin';
	export interface TabbedChildState extends CachedRenderState, CloseableState {
	    /**
	     * Whether the current child is the active/visible child
	     */
	    active?: boolean;
	    /**
	     * Should this child represent that it is in a changed state that is not persisted
	     */
	    changed?: boolean;
	}
	export type TabbedChild = Child & CloseableMixin<TabbedChildState> & CachedRenderMixin<TabbedChildState>;
	export interface TabbedMixinOptions extends ParentMixinOptions<TabbedChild>, StatefulOptions<CachedRenderState> {
	}
	export interface Tabbed<C extends TabbedChild> {
	    children: List<TabbedChild>;
	    activeChild: C;
	    /**
	     * Tag names used by sub parts of this widget
	     */
	    tagNames: {
	        tabBar: string;
	        tab: string;
	    };
	}
	export type TabbedMixin<C extends TabbedChild> = Tabbed<C> & ParentMixin<C> & CachedRenderMixin<CachedRenderState> & Destroyable;
	export interface TabbedMixinFactory extends ComposeFactory<TabbedMixin<TabbedChild>, TabbedMixinOptions> {
	} const createTabbedMixin: TabbedMixinFactory;
	export default createTabbedMixin;

}
declare module 'dojo-widgets/createTabbedPanel' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetState, WidgetOptions } from 'dojo-widgets/createWidget';
	import { TabbedMixin, TabbedChild, TabbedMixinOptions } from 'dojo-widgets/mixins/createTabbedMixin';
	export interface TabbedPanelOptions extends WidgetOptions<WidgetState>, TabbedMixinOptions {
	}
	export type TabbedPanel = Widget<WidgetState> & TabbedMixin<TabbedChild>;
	export interface TabbedPanelFactory extends ComposeFactory<TabbedPanel, TabbedPanelOptions> {
	} const createTabbedPanel: TabbedPanelFactory;
	export default createTabbedPanel;

}
declare module 'dojo-widgets/createTextInput' {
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Widget, WidgetOptions } from 'dojo-widgets/createWidget';
	import { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from 'dojo-widgets/mixins/createFormFieldMixin';
	export interface TypedTargetEvent<T extends EventTarget> extends Event {
	    target: T;
	}
	export interface TextInputOptions extends WidgetOptions<FormFieldMixinState<string>>, FormFieldMixinOptions<string, FormFieldMixinState<string>> {
	}
	export type TextInput = Widget<FormFieldMixinState<string>> & FormFieldMixin<string, FormFieldMixinState<string>>;
	export interface TextInputFactory extends ComposeFactory<TextInput, TextInputOptions> {
	} const createTextInput: TextInputFactory;
	export default createTextInput;

}
declare module 'dojo-widgets/main' {
	import createButton from 'dojo-widgets/createButton';
	import createContainer from 'dojo-widgets/createContainer';
	import createDijit from 'dojo-widgets/createDijit';
	import createLayoutContainer from 'dojo-widgets/createLayoutContainer';
	import createList from 'dojo-widgets/createList';
	import createPanel from 'dojo-widgets/createPanel';
	import createResizePanel from 'dojo-widgets/createResizePanel';
	import createTabbedPanel from 'dojo-widgets/createTabbedPanel';
	import createTextInput from 'dojo-widgets/createTextInput';
	import createWidget from 'dojo-widgets/createWidget';
	import projector from 'dojo-widgets/projector';
	export { createButton, createContainer, createDijit, createLayoutContainer, createList, createPanel, createResizePanel, createTabbedPanel, createTextInput, createWidget, projector };

}
declare module 'dojo-widgets/util/createMemoryStore' {
	import { Observable } from 'rxjs/Observable';
	import Promise from 'dojo-core/Promise';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	export type StoreIndex = number | string;
	export interface MemoryStorePragma {
	    /**
	     * The identity of the object
	     */
	    id?: StoreIndex;
	    /**
	     * Should the item be replaced if already exists.
	     */
	    replace?: boolean;
	}
	export interface MemoryStorePromise<T> extends Promise<T> {
	    /**
	     * Retrieve an object from the store based on the object's ID
	     * @param id The ID of the object to retrieve
	     */
	    get(id: StoreIndex): MemoryStorePromise<T>;
	    /**
	     * Put an item in the object store.
	     * @param item The item to put
	     * @param options The pragma to use when putting the object
	     */
	    put(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Add an item to the object store.
	     * @param add The item to add
	     * @param options The pragma to use when adding the object
	     */
	    add(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Patch an object in the store by providing a partial object.  The result will be a promise
	     * that resolves with the patched object.
	     * @param partial The partial object to patch the existing object with
	     * @param options The pragma to use when patching the object
	     */
	    patch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Remove an object from the store.
	     * @param id The ID of the object to remove
	     * @param item The object to remove
	     */
	    delete(id: StoreIndex): MemoryStorePromise<boolean>;
	    delete(item: T): MemoryStorePromise<boolean>;
	    /**
	     * Set the stores objects to an array
	     */
	    fromArray(items: T[]): MemoryStorePromise<void>;
	}
	export interface MemoryStoreOptions<T extends Object> {
	    /**
	     * Any initial data that should populate the store
	     */
	    data?: T[];
	    /**
	     * The property of each object to use as the identity for the object
	     */
	    idProperty?: StoreIndex;
	}
	export const enum ChangeTypes {
	    Add = 1,
	    Put = 2,
	    Patch = 3,
	    Delete = 4,
	}
	export interface ChangeRecord<T extends Object> {
	    type: ChangeTypes;
	    id: StoreIndex;
	    target?: T;
	}
	export interface MemoryStoreMixin<T extends Object> {
	    /**
	     * The property that determines the ID of the object (defaults to `id`)
	     */
	    idProperty: StoreIndex;
	    /**
	     * Retrieve an object from the store based on the object's ID
	     * @param id The ID of the object to retrieve
	     */
	    get(id: StoreIndex): MemoryStorePromise<T>;
	    /**
	     * Observe an object, any subsequent changes to the object can also be observed via the observable
	     * interface that is returned.  If the object is not present in the store, the observation will be
	     * immediatly completed.  If the object is deleted from the store, the observation will be completed
	     * @param id The ID of the object to observe
	     */
	    observe(id: StoreIndex): Observable<T>;
	    observe(): Observable<ChangeRecord<T>>;
	    /**
	     * Put an item in the object store.
	     * @param item The item to put
	     * @param options The pragma to use when putting the object
	     */
	    put(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Add an item to the object store.
	     * @param add The item to add
	     * @param options The pragma to use when adding the object
	     */
	    add(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Patch an object in the store by providing a partial object.  The result will be a promise
	     * that resolves with the patched object.
	     * @param partial The partial object to patch the existing object with
	     * @param options The pragma to use when patching the object
	     */
	    patch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;
	    /**
	     * Remove an object from the store.
	     * @param id The ID of the object to remove
	     * @param item The object to remove
	     */
	    delete(id: StoreIndex): MemoryStorePromise<boolean>;
	    delete(item: T): MemoryStorePromise<boolean>;
	    /**
	     * Set the stores objects to an array
	     */
	    fromArray(items: T[]): MemoryStorePromise<void>;
	}
	export type MemoryStore<T extends Object> = MemoryStoreMixin<T> & Destroyable;
	export interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {
	    <T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;
	    /**
	     * Creates a memory store from an array of objects
	     * @params data The array of data to create the memory store from
	     */
	    fromArray<T extends Object>(data: T[]): MemoryStore<T>;
	} const createMemoryStore: MemoryStoreFactory;
	export default createMemoryStore;

}
declare module 'dojo-widgets/util/has' {
	export * from 'dojo-core/has';

}
declare module 'dojo-widgets/util/query' {
	import { List } from 'immutable/immutable';
	import { ComposeFactory } from 'dojo-compose/compose';
	import Promise from 'dojo-core/Promise';
	export interface OrderedQuery<T> extends Query<T> {
	    thenBy(name: string, ascending?: boolean): this;
	}
	export interface Query<T> extends Promise<T> {
	    where(condition: Conditional): this;
	    filter<U>(callback: (item: T, store: any) => boolean): this;
	    select<U>(selection: string[] | ((item: T, store: any) => U)): Query<U>;
	    map<U>(callback: (item: T, store: any) => U): Query<U>;
	    take(): this;
	    skip(): this;
	    orderBy(name: string, ascending?: boolean): OrderedQuery<T>;
	    reverse(): this;
	    sort(callback: (a: T, b: T) => number): this;
	    groupBy<U>(): Query<U>;
	    distinct(): this;
	    union(): this;
	    intersect(): this;
	    except(): this;
	    toArray(): Promise<any[]>;
	    toList(): Promise<List<any>>;
	    construct<T>(factory: ComposeFactory<T, any>): Promise<T[]>;
	    first(): Promise<any>;
	    firstOrDefault(): Promise<any>;
	    elementAt(): Promise<any>;
	    count(): Promise<number>;
	    range(): this;
	    repeat(): this;
	    any(): this;
	    all(): this;
	    count(): Promise<number>;
	    sum(): Promise<number>;
	    min(): Promise<number>;
	    max(): Promise<number>;
	    average(): Promise<number>;
	    aggregate(): Promise<number>;
	    concat(): this;
	    join(): this;
	}
	export interface ConditionalExpression extends Object {
	}
	export interface Conditional {
	    expression: ConditionalExpression;
	}
	export interface ConditionalOperator extends Conditional {
	    and(): Condition;
	    or(): Condition;
	}
	export interface ConditionComparison<T> {
	    matches(condition: RegExp): ConditionalOperator;
	    equals(condition: T): ConditionalOperator;
	    contains(condition: T): ConditionalOperator;
	    lessThan(condition: T): ConditionalOperator;
	    greaterThan(condition: T): ConditionalOperator;
	}
	export interface Condition {
	    property(property: string): ConditionComparison<string>;
	}

}