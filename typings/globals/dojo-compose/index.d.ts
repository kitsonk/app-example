// Generated by typings
// Source: node_modules/dojo-compose/dist/umd/dojo-compose.d.ts
declare module 'dojo-compose/aspect' {
	export interface AdvisingFunction extends Function {
	    /**
	     * The next advice in an advice chain
	     */
	    next: AdvisingFunction;
	    /**
	     * The previous advice in an advice chain
	     */
	    previous: AdvisingFunction;
	}
	export interface DispatchAdvice<T> {
	    before?: BeforeAdvice[];
	    after?: AfterAdvice<T>[];
	    joinPoint: Function;
	}
	export interface BeforeAdvice {
	    /**
	     * Advice which is applied *before*, receiving the original arguments, if the advising function returns
	     * a value, it is passed further along taking the place of the original arguments.
	     * @param args The arguments the method was called with
	     */
	    (...args: any[]): any[] | void;
	}
	export interface AfterAdvice<T> {
	    /**
	     * Advice which is applied *after*, receiving the result and arguments from the join point.
	     *
	     * @param result The result from the function being advised
	     * @param args The arguments that were supplied to the advised function
	     * @returns The value returned from the advice is then the result of calling the method
	     */
	    (result: T, ...args: any[]): T;
	}
	export interface AroundAdvice<T> {
	    /**
	     * Advice which is applied *around*.  The advising function receives the original function and needs to
	     * return a new function which will then invoke the original function.
	     *
	     * @param origFn The original function
	     * @returns A new function which will inoke the original function.
	     */
	    (origFn: GenericFunction<T>): (...args: any[]) => T;
	}
	/**
	 * Types of advice
	 */
	export enum AdviceType {
	    Before = 0,
	    After = 1,
	    Around = 2,
	}
	export interface GenericFunction<T> {
	    (...args: any[]): T;
	}
	/**
	 * Apply advice *before* the supplied joinPoint (function)
	 * @param joinPoint A function that should have advice applied to
	 * @param advice The before advice
	 */
	export function before<F extends GenericFunction<any>>(joinPoint: F, advice: BeforeAdvice): F;
	/**
	 * Apply advice *after* the supplied joinPoint (function)
	 * @param joinPoint A function that should have advice applied to
	 * @param advice The after advice
	 */
	export function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: AfterAdvice<T>): F;
	/**
	 * Apply advice *around* the supplied joinPoint (function)
	 * @param joinPoint A function that should have advice applied to
	 * @param advice The around advice
	 */
	export function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: AroundAdvice<T>): F;

}
declare module 'dojo-compose/compose' {
	import { BeforeAdvice, AfterAdvice, AroundAdvice } from 'dojo-compose/aspect';
	/**
	 * A custom type guard that determines if the value is a ComposeFactory
	 * @param   value The target to check
	 * @returns       Return true if it is a ComposeFactory, otherwise false
	 */
	export function isComposeFactory(value: any): value is ComposeFactory<any, any>;
	/**
	 * Used to adapt any consructor functions or classes to a compose factory
	 */
	export interface GenericClass<T> {
	    new (...args: any[]): T;
	    prototype: T;
	}
	export interface ComposeInitializationFunction<T, O> {
	    /**
	     * A callback function use to initialize a new created instance
	     * @param instance The newly constructed instance
	     * @param options Any options that were passed to the factory
	     * @template T The type of the instance
	     * @template O The type of the options being passed
	     */
	    (instance: T, options?: O): void;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Extend the factory prototype with the supplied object literal, class, or factory
	     * @param extension The object literal, class or factory to extend
	     * @template T The original type of the factory
	     * @template U The type of the extension
	     * @template O The type of the factory options
	     * @template P The type of the extension factory options
	     */
	    extend<U>(extension: U | GenericClass<U>): ComposeFactory<T & U, O>;
	    extend<U, P>(extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface Compose {
	    /**
	     * Extend a compose factory prototype with the supplied object literal, class, or
	     * factory.
	     * @param base The base compose factory to extend
	     * @param extension The object literal, class or factory that is the extension
	     * @template T The base type of the factory
	     * @template U The type of the extension
	     * @template O The type of the base factory options
	     * @template P The type of the extension factory options
	     */
	    extend<T, O, U>(base: ComposeFactory<T, O>, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;
	    extend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface OverlayFunction<T> {
	    /**
	     * A function that takes a factories prototype, allowing it to change the prototype without
	     * mutating the type structure.
	     *
	     * @param proto The object literal that should be overlayed on the factories prototype.
	     * @template T The type of the factories prototype
	     */
	    (proto: T): void;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Provide a function that mutates the factories prototype but does not change the factory's class
	     * structure.
	     *
	     * @param overlayFunction The function which receives the factory's prototype
	     * @template T The type of the factory's prototype
	     */
	    overlay(overlayFunction: OverlayFunction<T>): this;
	}
	export interface Compose {
	    /**
	     * A static method that takes a compose factory and applies an overlay function to the factory,
	     * returning a new compose factory with a mutated prototype.
	     *
	     * @param base The base ComposeFactory
	     * @param overlayFunction The function which receives the base factory's prototype
	     * @template T The type of the factory's prototype
	     * @template O The options for the factory's creation
	     */
	    overlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;
	}
	export interface AspectAdvice {
	    /**
	     * Any methods where the supplied advice should be applied *before* the base method is invoked
	     */
	    before?: {
	        [method: string]: BeforeAdvice;
	    };
	    /**
	     * Any methods where the supplied advice should be applied *after* the base method is invoked
	     */
	    after?: {
	        [method: string]: AfterAdvice<any>;
	    };
	    /**
	     * Any methods where the supplied advice should be applied *around* the base method
	     */
	    around?: {
	        [method: string]: AroundAdvice<any>;
	    };
	}
	/**
	 * Either a class, object literal, or a factory
	 */
	export type ComposeMixinItem<T, O> = GenericClass<T> | T | ComposeFactory<T, O>;
	export interface ComposeMixinDescriptor<T, O, U, P> {
	    /**
	     * The class, object literal, or factory to be mixed in
	     */
	    mixin?: ComposeMixinItem<U, P>;
	    /**
	     * An initialize function to be executed upon construction
	     */
	    initialize?: ComposeInitializationFunction<T & U, O & P>;
	    /**
	     * Aspect Oriented Advice to be mixed into the factory
	     */
	    aspectAdvice?: AspectAdvice;
	}
	/**
	 * Identifies a compose factory or other object that can be
	 * transformed into a ComposeMixinDescriptor
	 */
	export interface ComposeMixinable<U, P> {
	    /**
	     * A method that offers up a ComposeMixinDescriptor to allow complex mixin in of factories
	     */
	    factoryDescriptor<T, O>(): ComposeMixinDescriptor<T, O, U, P>;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Mixin additional mixins, initialization logic, and aspect advice into the factory
	     * @param mixin An object literal that describes what to mixin
	     */
	    mixin<U, P>(mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;
	    mixin<U, P>(mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface Compose {
	    /**
	     * Mixin additional mixins, initialization logic, and aspect advice into a factory
	     * @param base The base factory that is the target of the mixin
	     * @param mixin An object literal that describes what to mixin
	     */
	    mixin<T, O, U, P>(base: ComposeFactory<T, O>, mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;
	    mixin<T, O, U, P>(base: ComposeFactory<T, O>, mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;
	}
	export interface GenericFunction<T> {
	    (...args: any[]): T;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Extract a method from another Class or Factory and add it to the returned factory
	     * @param base The base Class or Factory
	     * @param method The name of the method to extract
	     */
	    from(base: GenericClass<any> | ComposeFactory<any, any>, method: string): this;
	    /**
	     * Apply advice *before* the named method (join-point)
	     * @param method The method to apply the advice to
	     * @param advice The advice to be applied
	     */
	    before(method: string, advice: BeforeAdvice): this;
	    /**
	     * Apply advice *after* the named method (join-point)
	     * @param method The method to apply the advice to
	     * @param advice The advice to be applied
	     */
	    after<P>(method: string, advice: AfterAdvice<P>): this;
	    /**
	     * Apply advice *around* the named method (join-point)
	     * @param method The method to apply the advice to
	     * @param advice The advice to be applied
	     */
	    around<P>(method: string, advice: AroundAdvice<P>): this;
	    /**
	     * Provide an object literal which can contain a map of advice to apply
	     * @param advice An object literal which contains the maps of advice to apply
	     */
	    aspect(advice: AspectAdvice): this;
	}
	export interface Compose {
	    /**
	     * Extract a method from another Class or Factory and return it
	     * @param base The Class or Factory to extract from
	     * @param method The method name to be extracted
	     */
	    from<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string): T;
	    /**
	     * Apply advice *before* the named method (join-point)
	     * @param base The Class or Factory to extract the method from
	     * @param method The method name to apply the advice to
	     * @param advice The advice to apply
	     */
	    before<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;
	    before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;
	    /**
	     * Apply advice *after* the named method (join-point)
	     * @param base The Class or Factory to extract the method from
	     * @param method The method name to apply the advice to
	     * @param advice The advice to apply
	     */
	    after<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;
	    after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;
	    /**
	     * Apply advice *around* the named method (join-point)
	     * @param base The Class or Factory to extract the method from
	     * @param method The method name to apply the advice to
	     * @param advice The advice to apply
	     */
	    around<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;
	    around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;
	    /**
	     * Apply advice to methods that exist in the base factory using the supplied advice map
	     * @param base The Factory that contains the methods the advice will be applied to
	     * @param advice The map of advice to be applied
	     */
	    aspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Create a new instance
	     * @param options Options that are passed to the initialization functions of the factory
	     */
	    (options?: O): T;
	    /**
	     * The read only prototype of the factory
	     */
	    prototype: T;
	}
	export interface Compose {
	    /**
	     * Create a new factory based on a supplied Class, Factory or Object prototype with an optional
	     * initalization function
	     * @param base The base Class, Factory or Object prototype to use
	     * @param initFunction An optional function that will be passed the instance and any creation options
	     */
	    <T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	    <T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;
	    /**
	     * Create a new factory based on a supplied Class, Factory or Object prototype with an optional
	     * initialization function
	     * @param base The base Class, Facotry or Object prototype to use
	     * @param initFunction An optional function that will be passed the instance and nay creation options
	     */
	    create<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;
	    create<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;
	}
	export interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {
	    /**
	     * Add static properties to a factory
	     * @param staticProperties An object literal that contains methods and properties that should be "static" (e.g. added to
	     *                         the factory, instead of the factory's prototype)
	     */
	    static<S>(staticProperties: S): this & S;
	}
	export interface Compose {
	    /**
	     * Add static properties to a factory
	     * @param staticProperties An object literal that contains methods and properties that should be "static" (e.g. added to
	     *                         the factory, instead of the factory's prototype)
	     */
	    static<F extends ComposeFactory<T, O>, T, O, S>(factory: F, staticProperties: S): F & S;
	} const compose: Compose;
	export default compose;

}
declare module 'dojo-compose/main' {
	import compose from 'dojo-compose/compose';
	export default compose;
	export * from 'dojo-compose/compose';

}
declare module 'dojo-compose/mixins/createDestroyable' {
	import { Handle } from 'dojo-core/interfaces';
	import Promise from 'dojo-core/Promise';
	import { ComposeFactory } from 'dojo-compose/compose';
	export interface DestroyableOptions {
	}
	export interface Destroyable {
	    /**
	     * Take a handle and *own* it, which ensures that the handle's
	     * `destroy()` method is called when the *owner* is destroyed.
	     * @param handle The handle to own
	     * @returns A handle to *unown* the passed handle
	     */
	    own(handle: Handle): Handle;
	    /**
	     * Invoke `destroy()` on any owned handles.
	     * @returns A promise that resolves to `true` if successful, otherwise `false`
	     */
	    destroy(): Promise<boolean>;
	}
	export interface DestroyableFactory extends ComposeFactory<Destroyable, DestroyableOptions> {
	}
	/**
	 * A type guard that determines if the value is a Destroyable
	 * @param value The value to guard for
	 */
	export function isDestroyable(value: any): value is Destroyable; const createDestroyable: DestroyableFactory;
	export default createDestroyable;

}
declare module 'dojo-compose/mixins/createEvented' {
	import { EventObject, Handle } from 'dojo-core/interfaces';
	import { ComposeFactory } from 'dojo-compose/compose';
	import { Destroyable } from 'dojo-compose/mixins/createDestroyable';
	export interface TargettedEventObject extends EventObject {
	    /**
	     * The target of the event
	     */
	    target: any;
	}
	export interface ActionableOptions<E extends TargettedEventObject> {
	    [option: string]: any;
	    /**
	     * An event object
	     */
	    event?: E;
	}
	export interface Actionable<E extends TargettedEventObject> {
	    /**
	     * The *do* method of an Action, which can take a `options` property of an `event`
	     * @param options Options passed which includes an `event` object
	     */
	    do(options?: ActionableOptions<E>): any;
	}
	export interface EventedCallback<E extends EventObject> {
	    /**
	     * A callback that takes an `event` argument
	     * @param event The event object
	     */
	    (event: E): boolean | void;
	}
	/**
	 * Either an `EventedCallback` or something that is `Actionable`
	 */
	export type EventedListener<E extends TargettedEventObject> = EventedCallback<E> | Actionable<E>;
	/**
	 * A map of listeners where the key is the event `type`
	 */
	export interface EventedListenersMap {
	    [type: string]: EventedListener<TargettedEventObject>;
	}
	export interface EventedOptions {
	    /**
	     * Any listeners that should be attached during construction
	     */
	    listeners?: EventedListenersMap;
	}
	export interface EventedMixin {
	    /**
	     * Emit an event.
	     *
	     * The event is determined by the `event.type`, if there are no listeners for an event type,
	     * `emit` is essentially a noop.
	     * @param event The `EventObject` to be delivered to listeners based on `event.type`
	     */
	    emit<E extends EventObject>(event: E): void;
	    /**
	     * Attach a `listener` to a particular event `type`.
	     *
	     * @param type The event to attach the listener to
	     * @param listener Either a function which takes an emitted `event` object, or something that is `Actionable`
	     * @returns A handle which can be used to remove the listener
	     */
	    on(type: string, listener: EventedListener<TargettedEventObject>): Handle;
	}
	export type Evented = EventedMixin & Destroyable;
	export interface EventedFactory extends ComposeFactory<Evented, EventedOptions> {
	}
	/**
	 * An internal function that always returns an EventedCallback
	 * @param listener Either a `EventedCallback` or an `Actionable`
	 */
	export function resolveListener<E extends TargettedEventObject>(listener: EventedListener<E>): EventedCallback<E>; const createEvented: EventedFactory;
	export default createEvented;

}
declare module 'dojo-compose/mixins/createStateful' {
	import { Handle } from 'dojo-core/interfaces';
	import Promise from 'dojo-core/Promise';
	import { Observable } from 'rxjs/Rx';
	import { Evented, EventedOptions, EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';
	import { ComposeFactory } from 'dojo-compose/compose';
	/**
	 * Base State interface
	 */
	export interface State {
	    [prop: string]: any;
	}
	export interface ObservableState<S extends State> {
	    /**
	     * A method that allows the return of an `Observable` interface for a particular `id`
	     * @param id The ID to observe
	     */
	    observe(id: string): Observable<S>;
	    /**
	     * A method that allows the `Stateful` to provide a change to its state, instead of
	     * changing its state directly.
	     * @param partial The partial state to be *patched*
	     * @param options A map of options, which includes the `id` being observed
	     */
	    patch(partial: any, options?: {
	        id?: string;
	    }): Promise<S>;
	}
	export interface StatefulOptions<S extends State> extends EventedOptions {
	    /**
	     * State that should be set during creation
	     */
	    state?: S;
	    /**
	     * An ID to be used in conjunction with the `stateFrom` option to observe the state
	     */
	    id?: string;
	    /**
	     * An object that the Stateful should observe its state from, which supplies an `observe` and
	     * `patch` methods to be able to manage its state
	     */
	    stateFrom?: ObservableState<S>;
	}
	export interface StateChangeEvent<S extends State> extends TargettedEventObject {
	    /**
	     * The event type
	     */
	    type: string;
	    /**
	     * The state of the target
	     */
	    state: S;
	    /**
	     * A Stateful instance
	     */
	    target: Stateful<S>;
	}
	export interface StatefulMixin<S extends State> {
	    /**
	     * A read only view of the state
	     */
	    state: S;
	    /**
	     * Set the state on the instance.
	     *
	     * Set state can take a partial value, therefore if a key is ommitted from the value, it will not be changed.
	     * To *clear* a value, set a key to `undefined`
	     *
	     * @param value The state (potentially partial) to be set
	     */
	    setState(value: S): void;
	    /**
	     * Observe (and update) the state from an Observable
	     * @param id The ID to be observed on the Observable
	     * @param observable An object which provides a `observe` and `patch` methods which allow `Stateful` to be able to
	     *                   manage its state.
	     */
	    observeState(id: string, observable: ObservableState<S>): Handle;
	}
	export type Stateful<S extends State> = StatefulMixin<S> & Evented & {
	    /**
	     * Add a listener for an event
	     * @param type The event type to listen for
	     * @param listener The listener that will be called when the event occurs
	     */
	    on(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;
	    on(type: string, listener: EventedListener<TargettedEventObject>): Handle;
	};
	export interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {
	    <S extends State>(options?: StatefulOptions<S>): Stateful<S>;
	} const createStateful: StatefulFactory;
	export default createStateful;

}