// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Subject.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Subject' {
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Observer } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription, ISubscription, TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * @class Subject<T>
 */
export class Subject<T> extends Observable<T> implements Observer<T>, ISubscription {
    protected destination: Observer<T>;
    protected source: Observable<T>;
    static create: Function;
    constructor(destination?: Observer<T>, source?: Observable<T>);
    observers: Observer<T>[];
    isUnsubscribed: boolean;
    protected isStopped: boolean;
    protected hasErrored: boolean;
    protected errorValue: any;
    protected dispatching: boolean;
    protected hasCompleted: boolean;
    lift<T, R>(operator: Operator<T, R>): Observable<T>;
    add(subscription: TeardownLogic): Subscription;
    remove(subscription: Subscription): void;
    unsubscribe(): void;
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
    protected _unsubscribe(): void;
    next(value: T): void;
    error(err?: any): void;
    complete(): void;
    asObservable(): Observable<T>;
    protected _next(value: T): void;
    protected _finalNext(value: T): void;
    protected _error(err: any): void;
    protected _finalError(err: any): void;
    protected _complete(): void;
    protected _finalComplete(): void;
    private throwIfUnsubscribed();
}
}
declare module '@reactivex/RxJS/dist/cjs/Subject' {
import alias = require('~@reactivex/RxJS/dist/cjs/Subject');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/IfObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/IfObservable' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class IfObservable<T, R> extends Observable<T> {
    private condition;
    private thenSource;
    private elseSource;
    static create<T, R>(condition: () => boolean | void, thenSource?: SubscribableOrPromise<T> | void, elseSource?: SubscribableOrPromise<R> | void): Observable<T | R>;
    constructor(condition: () => boolean | void, thenSource?: SubscribableOrPromise<T> | void, elseSource?: SubscribableOrPromise<R> | void);
    protected _subscribe(subscriber: Subscriber<T | R>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/IfObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/IfObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/ErrorObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/ErrorObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
export interface DispatchArg {
    error: any;
    subscriber: any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ErrorObservable extends Observable<any> {
    error: any;
    private scheduler;
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    static create<T>(error: any, scheduler?: Scheduler): ErrorObservable;
    static dispatch(arg: DispatchArg): void;
    constructor(error: any, scheduler?: Scheduler);
    protected _subscribe(subscriber: any): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/ErrorObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/ErrorObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Observable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Observable' {
import { PartialObserver } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription, AnonymousSubscription, TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { IfObservable } from '~@reactivex/RxJS/dist/cjs/observable/IfObservable';
import { ErrorObservable } from '~@reactivex/RxJS/dist/cjs/observable/ErrorObservable';
export interface Subscribable<T> {
    subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): AnonymousSubscription;
}
export type SubscribableOrPromise<T> = Subscribable<T> | Promise<T>;
export type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
export class Observable<T> implements Subscribable<T> {
    _isScalar: boolean;
    protected source: Observable<any>;
    protected operator: Operator<any, T>;
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    constructor(subscribe?: <R>(subscriber: Subscriber<R>) => TeardownLogic);
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    static create: Function;
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    lift<R>(operator: Operator<T, R>): Observable<R>;
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): Subscription;
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void>;
    protected _subscribe(subscriber: Subscriber<any>): TeardownLogic;
    static if: typeof IfObservable.create;
    static throw: typeof ErrorObservable.create;
}
}
declare module '@reactivex/RxJS/dist/cjs/Observable' {
import alias = require('~@reactivex/RxJS/dist/cjs/Observable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/BoundCallbackObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/BoundCallbackObservable' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { AsyncSubject } from '~@reactivex/RxJS/dist/cjs/AsyncSubject';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class BoundCallbackObservable<T> extends Observable<T> {
    private callbackFunc;
    private selector;
    private args;
    scheduler: Scheduler;
    subject: AsyncSubject<T>;
    static create<R>(callbackFunc: (callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<R>(callbackFunc: (callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (...args: any[]) => any) => any, selector: (...args: any[]) => R, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<T>(callbackFunc: Function, selector?: void, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    static create<T>(callbackFunc: Function, selector?: (...args: any[]) => T, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    constructor(callbackFunc: Function, selector: Function, args: any[], scheduler: Scheduler);
    protected _subscribe(subscriber: Subscriber<T | T[]>): Subscription;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/BoundCallbackObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/BoundCallbackObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/bindCallback.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/bindCallback' {
import { BoundCallbackObservable } from '~@reactivex/RxJS/dist/cjs/observable/BoundCallbackObservable';
export const bindCallback: typeof BoundCallbackObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/bindCallback' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/bindCallback');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/bindCallback.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/bindCallback' {
import { bindCallback as staticBindCallback } from '~@reactivex/RxJS/dist/cjs/observable/bindCallback';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let bindCallback: typeof staticBindCallback;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/BoundNodeCallbackObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/BoundNodeCallbackObservable' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { AsyncSubject } from '~@reactivex/RxJS/dist/cjs/AsyncSubject';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class BoundNodeCallbackObservable<T> extends Observable<T> {
    private callbackFunc;
    private selector;
    private args;
    scheduler: Scheduler;
    subject: AsyncSubject<T>;
    static create<R>(callbackFunc: (callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): () => Observable<R>;
    static create<T, R>(callbackFunc: (v1: T, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T) => Observable<R>;
    static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2) => Observable<R>;
    static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;
    static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;
    static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;
    static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: Scheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;
    static create<T>(callbackFunc: Function, selector?: void, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    static create<T>(callbackFunc: Function, selector?: (...args: any[]) => T, scheduler?: Scheduler): (...args: any[]) => Observable<T>;
    constructor(callbackFunc: Function, selector: Function, args: any[], scheduler: Scheduler);
    protected _subscribe(subscriber: Subscriber<T | T[]>): Subscription;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/BoundNodeCallbackObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/BoundNodeCallbackObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/bindNodeCallback.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/bindNodeCallback' {
import { BoundNodeCallbackObservable } from '~@reactivex/RxJS/dist/cjs/observable/BoundNodeCallbackObservable';
export const bindNodeCallback: typeof BoundNodeCallbackObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/bindNodeCallback' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/bindNodeCallback');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/bindNodeCallback.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/bindNodeCallback' {
import { bindNodeCallback as staticBindNodeCallback } from '~@reactivex/RxJS/dist/cjs/observable/bindNodeCallback';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let bindNodeCallback: typeof staticBindNodeCallback;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/OuterSubscriber.d.ts
declare module '~@reactivex/RxJS/dist/cjs/OuterSubscriber' {
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class OuterSubscriber<T, R> extends Subscriber<T> {
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: InnerSubscriber<T, R>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/OuterSubscriber' {
import alias = require('~@reactivex/RxJS/dist/cjs/OuterSubscriber');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/InnerSubscriber.d.ts
declare module '~@reactivex/RxJS/dist/cjs/InnerSubscriber' {
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class InnerSubscriber<T, R> extends Subscriber<R> {
    private parent;
    private outerValue;
    private outerIndex;
    private index;
    constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);
    protected _next(value: R): void;
    protected _error(error: any): void;
    protected _complete(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/InnerSubscriber' {
import alias = require('~@reactivex/RxJS/dist/cjs/InnerSubscriber');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/combineLatest.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/combineLatest' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from this Observable with values from
 * Observables passed as arguments. This is done by subscribing to each
 * Observable, in order, and collecting an array of each of the most recent
 * values any time any of the input Observables emits, then either taking that
 * array and passing it as arguments to an optional `project` function and
 * emitting the return value of that, or just emitting the array of recent
 * values directly if there is no `project` function.
 *
 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method combineLatest
 * @owner Observable
 */
export function combineLatest<T, R>(...observables: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R>;
export interface CombineLatestSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    <R>(array: ObservableInput<any>[]): Observable<R>;
    <R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
}
export function combineLatestStatic<T>(v1: ObservableInput<T>, scheduler?: Scheduler): Observable<[T]>;
export function combineLatestStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<[T, T2]>;
export function combineLatestStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<[T, T2, T3]>;
export function combineLatestStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<[T, T2, T3, T4]>;
export function combineLatestStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<[T, T2, T3, T4, T5]>;
export function combineLatestStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<[T, T2, T3, T4, T5, T6]>;
export function combineLatestStatic<T, R>(v1: ObservableInput<T>, project: (v1: T) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | Scheduler>): Observable<R>;
export function combineLatestStatic<R>(array: ObservableInput<any>[], scheduler?: Scheduler): Observable<R>;
export function combineLatestStatic<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R, scheduler?: Scheduler): Observable<R>;
export class CombineLatestOperator<T, R> implements Operator<T, R> {
    private project;
    constructor(project?: (...values: Array<any>) => R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {
    private project;
    private active;
    private values;
    private observables;
    private toRespond;
    constructor(destination: Subscriber<R>, project?: (...values: Array<any>) => R);
    protected _next(observable: any): void;
    protected _complete(): void;
    notifyComplete(unused: Subscriber<R>): void;
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    private _tryProject(values);
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/combineLatest' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/combineLatest');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/combineLatest.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/combineLatest' {
import { combineLatestStatic } from '~@reactivex/RxJS/dist/cjs/operator/combineLatest';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let combineLatest: typeof combineLatestStatic;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/concat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/concat' {
import { concatStatic } from '~@reactivex/RxJS/dist/cjs/operator/concat';
export const concat: typeof concatStatic;
}
declare module '@reactivex/RxJS/dist/cjs/observable/concat' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/concat');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/concat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/concat' {
import { concat as concatStatic } from '~@reactivex/RxJS/dist/cjs/observable/concat';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let concat: typeof concatStatic;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/DeferObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/DeferObservable' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class DeferObservable<T> extends Observable<T> {
    private observableFactory;
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * @see {@link create}
     *
     * @param {function(): Observable|Promise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    static create<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T>;
    constructor(observableFactory: () => SubscribableOrPromise<T> | void);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/DeferObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/DeferObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/defer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/defer' {
import { DeferObservable } from '~@reactivex/RxJS/dist/cjs/observable/DeferObservable';
export const defer: typeof DeferObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/defer' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/defer');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/defer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/defer' {
import { defer as staticDefer } from '~@reactivex/RxJS/dist/cjs/observable/defer';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let defer: typeof staticDefer;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/EmptyObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/EmptyObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
export interface DispatchArg<T> {
    subscriber: Subscriber<T>;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class EmptyObservable<T> extends Observable<T> {
    private scheduler;
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    static create<T>(scheduler?: Scheduler): Observable<T>;
    static dispatch<T>(arg: DispatchArg<T>): void;
    constructor(scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/EmptyObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/EmptyObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/empty.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/empty' {
import { EmptyObservable } from '~@reactivex/RxJS/dist/cjs/observable/EmptyObservable';
export const empty: typeof EmptyObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/empty' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/empty');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/empty.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/empty' {
import { empty as staticEmpty } from '~@reactivex/RxJS/dist/cjs/observable/empty';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let empty: typeof staticEmpty;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/ForkJoinObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/ForkJoinObservable' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ForkJoinObservable<T> extends Observable<T> {
    private sources;
    private resultSelector;
    constructor(sources: Array<SubscribableOrPromise<any>>, resultSelector?: (...values: Array<any>) => T);
    /**
     * @param sources
     * @return {any}
     * @static true
     * @name forkJoin
     * @owner Observable
     */
    static create<T>(...sources: Array<SubscribableOrPromise<any> | Array<SubscribableOrPromise<any>> | ((...values: Array<any>) => any)>): Observable<T>;
    protected _subscribe(subscriber: Subscriber<any>): Subscription;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/ForkJoinObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/ForkJoinObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/forkJoin.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/forkJoin' {
import { ForkJoinObservable } from '~@reactivex/RxJS/dist/cjs/observable/ForkJoinObservable';
export const forkJoin: typeof ForkJoinObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/forkJoin' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/forkJoin');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/forkJoin.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/forkJoin' {
import { forkJoin as staticForkJoin } from '~@reactivex/RxJS/dist/cjs/observable/forkJoin';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let forkJoin: typeof staticForkJoin;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/FromObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/FromObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromObservable<T> extends Observable<T> {
    private ish;
    private scheduler;
    constructor(ish: ObservableInput<T>, scheduler: Scheduler);
    /**
     * @param ish
     * @param mapFnOrScheduler
     * @param thisArg
     * @param lastScheduler
     * @return {any}
     * @static true
     * @name from
     * @owner Observable
     */
    static create<T>(ish: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
    static create<T, R>(ish: ArrayLike<T>, mapFn: (x: any, y: number) => R, thisArg?: any, scheduler?: Scheduler): Observable<R>;
    protected _subscribe(subscriber: Subscriber<T>): any;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/FromObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/FromObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/from.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/from' {
import { FromObservable } from '~@reactivex/RxJS/dist/cjs/observable/FromObservable';
export const from: typeof FromObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/from' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/from');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/from.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/from' {
import { from as staticFrom } from '~@reactivex/RxJS/dist/cjs/observable/from';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let from: typeof staticFrom;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/FromEventObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/FromEventObservable' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
export type NodeStyleEventEmmitter = {
    addListener: (eventName: string, handler: Function) => void;
    removeListener: (eventName: string, handler: Function) => void;
};
export type JQueryStyleEventEmitter = {
    on: (eventName: string, handler: Function) => void;
    off: (eventName: string, handler: Function) => void;
};
export type EventTargetLike = EventTarget | NodeStyleEventEmmitter | JQueryStyleEventEmitter | NodeList | HTMLCollection;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromEventObservable<T, R> extends Observable<T> {
    private sourceObj;
    private eventName;
    private selector;
    /**
     * @param sourceObj
     * @param eventName
     * @param selector
     * @return {FromEventObservable}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    static create<T>(sourceObj: EventTargetLike, eventName: string, selector?: (...args: Array<any>) => T): Observable<T>;
    constructor(sourceObj: EventTargetLike, eventName: string, selector?: (...args: Array<any>) => T);
    private static setupSubscription<T>(sourceObj, eventName, handler, subscriber);
    protected _subscribe(subscriber: Subscriber<T>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/FromEventObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/FromEventObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/fromEvent.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/fromEvent' {
import { FromEventObservable } from '~@reactivex/RxJS/dist/cjs/observable/FromEventObservable';
export const fromEvent: typeof FromEventObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/fromEvent' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/fromEvent');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/fromEvent.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/fromEvent' {
import { fromEvent as staticFromEvent } from '~@reactivex/RxJS/dist/cjs/observable/fromEvent';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let fromEvent: typeof staticFromEvent;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/FromEventPatternObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/FromEventPatternObservable' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class FromEventPatternObservable<T, R> extends Observable<T> {
    private addHandler;
    private removeHandler;
    private selector;
    /**
     * @param addHandler
     * @param removeHandler
     * @param selector
     * @return {FromEventPatternObservable}
     * @static true
     * @name fromEventPattern
     * @owner Observable
     */
    static create<T>(addHandler: (handler: Function) => any, removeHandler: (handler: Function) => void, selector?: (...args: Array<any>) => T): FromEventPatternObservable<T, {}>;
    constructor(addHandler: (handler: Function) => any, removeHandler: (handler: Function) => void, selector?: (...args: Array<any>) => T);
    protected _subscribe(subscriber: Subscriber<T>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/FromEventPatternObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/FromEventPatternObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/fromEventPattern.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/fromEventPattern' {
import { FromEventPatternObservable } from '~@reactivex/RxJS/dist/cjs/observable/FromEventPatternObservable';
export const fromEventPattern: typeof FromEventPatternObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/fromEventPattern' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/fromEventPattern');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/fromEventPattern.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/fromEventPattern' {
import { fromEventPattern as staticFromEventPattern } from '~@reactivex/RxJS/dist/cjs/observable/fromEventPattern';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let fromEventPattern: typeof staticFromEventPattern;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/PromiseObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/PromiseObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class PromiseObservable<T> extends Observable<T> {
    private promise;
    scheduler: Scheduler;
    value: T;
    /**
     * @param promise
     * @param scheduler
     * @return {PromiseObservable}
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    static create<T>(promise: Promise<T>, scheduler?: Scheduler): Observable<T>;
    constructor(promise: Promise<T>, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/PromiseObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/PromiseObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/fromPromise.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/fromPromise' {
import { PromiseObservable } from '~@reactivex/RxJS/dist/cjs/observable/PromiseObservable';
export const fromPromise: typeof PromiseObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/fromPromise' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/fromPromise');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/fromPromise.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/fromPromise' {
import { fromPromise as staticFromPromise } from '~@reactivex/RxJS/dist/cjs/observable/fromPromise';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let fromPromise: typeof staticFromPromise;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/IntervalObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/IntervalObservable' {
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class IntervalObservable extends Observable<number> {
    private period;
    private scheduler;
    /**
     * Creates an Observable that emits sequential numbers every specified
     * interval of time, on a specified Scheduler.
     *
     * <span class="informal">Emits incremental numbers periodically in time.
     * </span>
     *
     * <img src="./img/interval.png" width="100%">
     *
     * `interval` returns an Observable that emits an infinite sequence of
     * ascending integers, with a constant interval of time of your choosing
     * between those emissions. The first emission is not sent immediately, but
     * only after the first period has passed. By default, this operator uses the
     * `async` Scheduler to provide a notion of time, but you may pass any
     * Scheduler to it.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
     * var numbers = Rx.Observable.interval(1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link delay}
     *
     * @param {number} [period=0] The interval size in milliseconds (by default)
     * or the time unit determined by the scheduler's clock.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a sequential number each time
     * interval.
     * @static true
     * @name interval
     * @owner Observable
     */
    static create(period?: number, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): void;
    constructor(period?: number, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/IntervalObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/IntervalObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/interval.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/interval' {
import { IntervalObservable } from '~@reactivex/RxJS/dist/cjs/observable/IntervalObservable';
export const interval: typeof IntervalObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/interval' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/interval');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/interval.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/interval' {
import { interval as staticInterval } from '~@reactivex/RxJS/dist/cjs/observable/interval';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let interval: typeof staticInterval;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/merge.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/merge' {
import { mergeStatic } from '~@reactivex/RxJS/dist/cjs/operator/merge';
export const merge: typeof mergeStatic;
}
declare module '@reactivex/RxJS/dist/cjs/observable/merge' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/merge');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/merge.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/merge' {
import { merge as mergeStatic } from '~@reactivex/RxJS/dist/cjs/observable/merge';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let merge: typeof mergeStatic;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/race.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/race' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables
 * @param {...Observables} ...observables sources used to race for which Observable emits first.
 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 */
export function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
export interface RaceSignature<T> {
    (...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
    <R>(...observables: Array<Observable<any> | Array<Observable<T>>>): Observable<R>;
}
/**
 * Returns an Observable that mirrors the first source Observable to emit an item.
 * @param {...Observables} ...observables sources used to race for which Observable emits first.
 * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
 * @static true
 * @name race
 * @owner Observable
 */
export function raceStatic<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
export class RaceOperator<T> implements Operator<T, T> {
    call(subscriber: Subscriber<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class RaceSubscriber<T> extends OuterSubscriber<T, T> {
    private hasFirst;
    private observables;
    private subscriptions;
    constructor(destination: Subscriber<T>);
    protected _next(observable: any): void;
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/race' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/race');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/race.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/race' {
import { raceStatic } from '~@reactivex/RxJS/dist/cjs/operator/race';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let race: typeof raceStatic;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/NeverObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/NeverObservable' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class NeverObservable<T> extends Observable<T> {
    /**
     * Creates an Observable that emits no items to the Observer.
     *
     * <span class="informal">An Observable that never emits anything.</span>
     *
     * <img src="./img/never.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that emits
     * neither values nor errors nor the completion notification. It can be used
     * for testing purposes or for composing with other Observables. Please not
     * that by never emitting a complete notification, this Observable keeps the
     * subscription from being disposed automatically. Subscriptions need to be
     * manually disposed.
     *
     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
     * function info() {
     *   console.log('Will not be called');
     * }
     * var result = Rx.Observable.never().startWith(7);
     * result.subscribe(x => console.log(x), info, info);
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link of}
     * @see {@link throw}
     *
     * @return {Observable} A "never" Observable: never emits anything.
     * @static true
     * @name never
     * @owner Observable
     */
    static create<T>(): NeverObservable<T>;
    constructor();
    protected _subscribe(subscriber: Subscriber<T>): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/NeverObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/NeverObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/never.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/never' {
import { NeverObservable } from '~@reactivex/RxJS/dist/cjs/observable/NeverObservable';
export const never: typeof NeverObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/never' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/never');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/never.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/never' {
import { never as staticNever } from '~@reactivex/RxJS/dist/cjs/observable/never';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let never: typeof staticNever;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/ArrayObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/ArrayObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class ArrayObservable<T> extends Observable<T> {
    array: T[];
    scheduler: Scheduler;
    static create<T>(array: T[], scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: Scheduler): Observable<T>;
    static of<T>(...array: Array<T | Scheduler>): Observable<T>;
    static dispatch(state: any): void;
    value: any;
    constructor(array: T[], scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/ArrayObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/ArrayObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/of.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/of' {
import { ArrayObservable } from '~@reactivex/RxJS/dist/cjs/observable/ArrayObservable';
export const of: typeof ArrayObservable.of;
}
declare module '@reactivex/RxJS/dist/cjs/observable/of' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/of');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/of.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/of' {
import { of as staticOf } from '~@reactivex/RxJS/dist/cjs/observable/of';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let of: typeof staticOf;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/RangeObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/RangeObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class RangeObservable extends Observable<number> {
    /**
     * Creates an Observable that emits a sequence of numbers within a specified
     * range.
     *
     * <span class="informal">Emits a sequence of numbers in a range.</span>
     *
     * <img src="./img/range.png" width="100%">
     *
     * `range` operator emits a range of sequential integers, in order, where you
     * select the `start` of the range and its `length`. By default, uses no
     * Scheduler and just delivers the notifications synchronously, but may use
     * an optional Scheduler to regulate those deliveries.
     *
     * @example <caption>Emits the numbers 1 to 10</caption>
     * var numbers = Rx.Observable.range(1, 10);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link timer}
     * @see {@link interval}
     *
     * @param {number} [start=0] The value of the first integer in the sequence.
     * @param {number} [count=0] The number of sequential integers to generate.
     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
     * the emissions of the notifications.
     * @return {Observable} An Observable of numbers that emits a finite range of
     * sequential integers.
     * @static true
     * @name range
     * @owner Observable
     */
    static create(start?: number, count?: number, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): void;
    private start;
    private _count;
    private scheduler;
    constructor(start: number, count: number, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/RangeObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/RangeObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/range.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/range' {
import { RangeObservable } from '~@reactivex/RxJS/dist/cjs/observable/RangeObservable';
export const range: typeof RangeObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/range' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/range');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/range.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/range' {
import { range as staticRange } from '~@reactivex/RxJS/dist/cjs/observable/range';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let range: typeof staticRange;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/throw.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/throw' {}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/TimerObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/TimerObservable' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
export class TimerObservable extends Observable<number> {
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` Scheduler to provide a notion of time, but you
     * may pass any Scheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The Scheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    static create(initialDelay?: number | Date, period?: number | Scheduler, scheduler?: Scheduler): Observable<number>;
    static dispatch(state: any): any;
    private period;
    private dueTime;
    private scheduler;
    constructor(dueTime?: number | Date, period?: number | Scheduler, scheduler?: Scheduler);
    protected _subscribe(subscriber: Subscriber<number>): TeardownLogic;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/TimerObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/TimerObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/timer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/timer' {
import { TimerObservable } from '~@reactivex/RxJS/dist/cjs/observable/TimerObservable';
export const timer: typeof TimerObservable.create;
}
declare module '@reactivex/RxJS/dist/cjs/observable/timer' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/timer');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/timer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/timer' {
import { timer as staticTimer } from '~@reactivex/RxJS/dist/cjs/observable/timer';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let timer: typeof staticTimer;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/zip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/zip' {
import { zipStatic } from '~@reactivex/RxJS/dist/cjs/operator/zip';
export const zip: typeof zipStatic;
}
declare module '@reactivex/RxJS/dist/cjs/observable/zip' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/zip');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/observable/zip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/observable/zip' {
import { zip as zipStatic } from '~@reactivex/RxJS/dist/cjs/observable/zip';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    namespace Observable {
        let zip: typeof zipStatic;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/buffer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/buffer' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */
export function buffer<T>(closingNotifier: Observable<any>): Observable<T[]>;
export interface BufferSignature<T> {
    (closingNotifier: Observable<any>): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/buffer' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/buffer');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/buffer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/buffer' {
import { BufferSignature } from '~@reactivex/RxJS/dist/cjs/operator/buffer';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        buffer: BufferSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/bufferCount.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/bufferCount' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */
export function bufferCount<T>(bufferSize: number, startBufferEvery?: number): Observable<T[]>;
export interface BufferCountSignature<T> {
    (bufferSize: number, startBufferEvery?: number): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/bufferCount' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/bufferCount');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/bufferCount.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/bufferCount' {
import { BufferCountSignature } from '~@reactivex/RxJS/dist/cjs/operator/bufferCount';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        bufferCount: BufferCountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/bufferTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/bufferTime' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */
export function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval?: number, scheduler?: Scheduler): Observable<T[]>;
export interface BufferTimeSignature<T> {
    (bufferTimeSpan: number, bufferCreationInterval?: number, scheduler?: Scheduler): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/bufferTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/bufferTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/bufferTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/bufferTime' {
import { BufferTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/bufferTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        bufferTime: BufferTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/bufferToggle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/bufferToggle' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
export function bufferToggle<T, O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): Observable<T[]>;
export interface BufferToggleSignature<T> {
    <O>(openings: SubscribableOrPromise<O>, closingSelector: (value: O) => SubscribableOrPromise<any>): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/bufferToggle' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/bufferToggle');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/bufferToggle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/bufferToggle' {
import { BufferToggleSignature } from '~@reactivex/RxJS/dist/cjs/operator/bufferToggle';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        bufferToggle: BufferToggleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/bufferWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/bufferWhen' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */
export function bufferWhen<T>(closingSelector: () => Observable<any>): Observable<T[]>;
export interface BufferWhenSignature<T> {
    (closingSelector: () => Observable<any>): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/bufferWhen' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/bufferWhen');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/bufferWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/bufferWhen' {
import { BufferWhenSignature } from '~@reactivex/RxJS/dist/cjs/operator/bufferWhen';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        bufferWhen: BufferWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/cache.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/cache' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {Observable<any>}
 * @method cache
 * @owner Observable
 */
export function cache<T>(bufferSize?: number, windowTime?: number, scheduler?: Scheduler): Observable<T>;
export interface CacheSignature<T> {
    (bufferSize?: number, windowTime?: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/cache' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/cache');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/cache.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/cache' {
import { CacheSignature } from '~@reactivex/RxJS/dist/cjs/operator/cache';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        cache: CacheSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/catch.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/catch' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} an observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @owner Observable
 */
export function _catch<T, R>(selector: (err: any, caught: Observable<T>) => Observable<R>): Observable<R>;
export interface CatchSignature<T> {
    <R>(selector: (err: any, caught: Observable<T>) => Observable<R>): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/catch' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/catch');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/catch.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/catch' {
import { CatchSignature } from '~@reactivex/RxJS/dist/cjs/operator/catch';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        catch: CatchSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/combineAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/combineAll' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Converts a higher-order Observable into a first-order Observable by waiting
 * for the outer Observable to complete, then applying {@link combineLatest}.
 *
 * <span class="informal">Flattens an Observable-of-Observables by applying
 * {@link combineLatest} when the Observable-of-Observables completes.</span>
 *
 * <img src="./img/combineAll.png" width="100%">
 *
 * Takes an Observable of Observables, and collects all Observables from it.
 * Once the outer Observable completes, it subscribes to all collected
 * Observables and combines their values using the {@link combineLatest}
 * strategy, such that:
 * - Every time an inner Observable emits, the output Observable emits.
 * - When the returned observable emits, it emits all of the latest values by:
 *   - If a `project` function is provided, it is called with each recent value
 *     from each inner Observable in whatever order they arrived, and the result
 *     of the `project` function is what is emitted by the output Observable.
 *   - If there is no `project` function, an array of all of the most recent
 *     values is emitted by the output Observable.
 *
 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev =>
 *   Rx.Observable.interval(Math.random()*2000).take(3)
 * ).take(2);
 * var result = higherOrder.combineAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 * @see {@link mergeAll}
 *
 * @param {function} [project] An optional function to map the most recent
 * values from each inner Observable into a new result. Takes each of the most
 * recent values from each collected inner Observable as arguments, in order.
 * @return {Observable} An Observable of projected results or arrays of recent
 * values.
 * @method combineAll
 * @owner Observable
 */
export function combineAll<R>(project?: (...values: Array<any>) => R): Observable<R>;
export interface CombineAllSignature<T> {
    (): Observable<T[]>;
    <R>(project?: (...values: Array<T>) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/combineAll' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/combineAll');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/combineAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/combineAll' {
import { CombineAllSignature } from '~@reactivex/RxJS/dist/cjs/operator/combineAll';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        combineAll: CombineAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/combineLatest.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/combineLatest' {
import { CombineLatestSignature } from '~@reactivex/RxJS/dist/cjs/operator/combineLatest';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        combineLatest: CombineLatestSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/concat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/concat' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {Observable} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
export function concat<T, R>(...observables: Array<ObservableInput<any> | Scheduler>): Observable<R>;
export interface ConcatSignature<T> {
    (scheduler?: Scheduler): Observable<T>;
    <T2>(v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    (...observables: Array<ObservableInput<T> | Scheduler>): Observable<T>;
    <R>(...observables: Array<ObservableInput<any> | Scheduler>): Observable<R>;
}
export function concatStatic<T>(v1: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
export function concatStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
export function concatStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function concatStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function concatStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function concatStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function concatStatic<T>(...observables: (ObservableInput<T> | Scheduler)[]): Observable<T>;
export function concatStatic<T, R>(...observables: (ObservableInput<any> | Scheduler)[]): Observable<R>;
}
declare module '@reactivex/RxJS/dist/cjs/operator/concat' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/concat');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/concat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/concat' {
import { ConcatSignature } from '~@reactivex/RxJS/dist/cjs/operator/concat';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        concat: ConcatSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/concatAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/concatAll' {
import { Subscribable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
export function concatAll<T>(): T;
export interface ConcatAllSignature<T> {
    (): T;
    <R>(): Subscribable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/concatAll' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/concatAll');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/concatAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/concatAll' {
import { ConcatAllSignature } from '~@reactivex/RxJS/dist/cjs/operator/concatAll';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        concatAll: ConcatAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/concatMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/concatMap' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} an observable of values merged from the projected
 * Observables as they were subscribed to, one at a time. Optionally, these
 * values may have been projected from a passed `projectResult` argument.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
export function concatMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): any;
export interface ConcatMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/concatMap' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/concatMap');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/concatMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/concatMap' {
import { ConcatMapSignature } from '~@reactivex/RxJS/dist/cjs/operator/concatMap';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        concatMap: ConcatMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/concatMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/concatMapTo' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
export function concatMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface ConcatMapToSignature<T> {
    <R>(observable: ObservableInput<R>): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/concatMapTo' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/concatMapTo');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/concatMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/concatMapTo' {
import { ConcatMapToSignature } from '~@reactivex/RxJS/dist/cjs/operator/concatMapTo';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        concatMapTo: ConcatMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/count.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/count' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting an value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */
export function count<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<number>;
export interface CountSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<number>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/count' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/count');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/count.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/count' {
import { CountSignature } from '~@reactivex/RxJS/dist/cjs/operator/count';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        count: CountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/dematerialize.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/dematerialize' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that transforms Notification objects into the items or notifications they represent.
 *
 * @see {@link Notification}
 *
 * @return {Observable} an Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */
export function dematerialize<T>(): Observable<any>;
export interface DematerializeSignature<T> {
    <R>(): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/dematerialize' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/dematerialize');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/dematerialize.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/dematerialize' {
import { DematerializeSignature } from '~@reactivex/RxJS/dist/cjs/operator/dematerialize';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        dematerialize: DematerializeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/debounce.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/debounce' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns the source Observable delayed by the computed debounce duration,
 * with the duration lengthened if a new source item arrives before the delay
 * duration ends.
 * In practice, for each item emitted on the source, this operator holds the
 * latest item, waits for a silence as long as the `durationSelector` specifies,
 * and only then emits the latest source item on the result Observable.
 * @param {function} durationSelector function for computing the timeout duration for each item.
 * @return {Observable} an Observable the same as source Observable, but drops items.
 * @method debounce
 * @owner Observable
 */
export function debounce<T>(durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
export interface DebounceSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/debounce' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/debounce');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/debounce.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/debounce' {
import { DebounceSignature } from '~@reactivex/RxJS/dist/cjs/operator/debounce';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        debounce: DebounceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/debounceTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/debounceTime' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * Returns the source Observable delayed by the computed debounce duration,
 * with the duration lengthened if a new source item arrives before the delay
 * duration ends.
 * In practice, for each item emitted on the source, this operator holds the
 * latest item, waits for a silence for the `dueTime` length, and only then
 * emits the latest source item on the result Observable.
 * Optionally takes a scheduler for manging timers.
 * @param {number} dueTime the timeout value for the window of time required to not drop the item.
 * @param {Scheduler} [scheduler] the Scheduler to use for managing the timers that handle the timeout for each item.
 * @return {Observable} an Observable the same as source Observable, but drops items.
 * @method debounceTime
 * @owner Observable
 */
export function debounceTime<T>(dueTime: number, scheduler?: Scheduler): Observable<T>;
export interface DebounceTimeSignature<T> {
    (dueTime: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/debounceTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/debounceTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/debounceTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/debounceTime' {
import { DebounceTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/debounceTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        debounceTime: DebounceTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/defaultIfEmpty.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/defaultIfEmpty' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits the elements of the source or a specified default value if empty.
 * @param {any} defaultValue the default value used if source is empty; defaults to null.
 * @return {Observable} an Observable of the items emitted by the where empty values are replaced by the specified default value or null.
 * @method defaultIfEmpty
 * @owner Observable
 */
export function defaultIfEmpty<T, R>(defaultValue?: R): Observable<T | R>;
export interface DefaultIfEmptySignature<T> {
    (defaultValue?: T): Observable<T>;
    <R>(defaultValue?: R): Observable<T | R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/defaultIfEmpty' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/defaultIfEmpty');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/defaultIfEmpty.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/defaultIfEmpty' {
import { DefaultIfEmptySignature } from '~@reactivex/RxJS/dist/cjs/operator/defaultIfEmpty';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        defaultIfEmpty: DefaultIfEmptySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/delay.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/delay' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The Scheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
export function delay<T>(delay: number | Date, scheduler?: Scheduler): Observable<T>;
export interface DelaySignature<T> {
    (delay: number | Date, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/delay' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/delay');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/delay.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/delay' {
import { DelaySignature } from '~@reactivex/RxJS/dist/cjs/operator/delay';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        delay: DelaySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/delayWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/delayWhen' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that delays the emission of items from the source Observable
 * by a subscription delay and a delay selector function for each element.
 * @param {Function} selector function to retrieve a sequence indicating the delay for each given element.
 * @param {Observable} sequence indicating the delay for the subscription to the source.
 * @return {Observable} an Observable that delays the emissions of the source Observable by the specified timeout or Date.
 * @method delayWhen
 * @owner Observable
 */
export function delayWhen<T>(delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): Observable<T>;
export interface DelayWhenSignature<T> {
    (delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/delayWhen' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/delayWhen');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/delayWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/delayWhen' {
import { DelayWhenSignature } from '~@reactivex/RxJS/dist/cjs/operator/delayWhen';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        delayWhen: DelayWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/distinctUntilChanged.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/distinctUntilChanged' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 * If a comparator function is not provided, an equality check is used by default.
 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
export function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): Observable<T>;
export interface DistinctUntilChangedSignature<T> {
    (compare?: (x: T, y: T) => boolean): Observable<T>;
    <K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/distinctUntilChanged' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/distinctUntilChanged');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/distinctUntilChanged.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/distinctUntilChanged' {
import { DistinctUntilChangedSignature } from '~@reactivex/RxJS/dist/cjs/operator/distinctUntilChanged';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        distinctUntilChanged: DistinctUntilChangedSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/do.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/do' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { PartialObserver } from '~@reactivex/RxJS/dist/cjs/Observer';
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
export function _do<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void), error?: (e: any) => void, complete?: () => void): Observable<T>;
export interface DoSignature<T> {
    (next: (x: T) => void, error?: (e: any) => void, complete?: () => void): Observable<T>;
    (observer: PartialObserver<T>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/do' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/do');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/do.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/do' {
import { DoSignature } from '~@reactivex/RxJS/dist/cjs/operator/do';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        do: DoSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/expand.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/expand' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * Returns an Observable where for each item in the source Observable, the supplied function is applied to each item,
 * resulting in a new value to then be applied again with the function.
 * @param {function} project the function for projecting the next emitted item of the Observable.
 * @param {number} [concurrent] the max number of observables that can be created concurrently. defaults to infinity.
 * @param {Scheduler} [scheduler] The Scheduler to use for managing the expansions.
 * @return {Observable} an Observable containing the expansions of the source Observable.
 * @method expand
 * @owner Observable
 */
export function expand<T, R>(project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: Scheduler): Observable<R>;
export interface ExpandSignature<T> {
    (project: (value: T, index: number) => Observable<T>, concurrent?: number, scheduler?: Scheduler): Observable<T>;
    <R>(project: (value: T, index: number) => Observable<R>, concurrent?: number, scheduler?: Scheduler): Observable<R>;
}
export class ExpandOperator<T, R> implements Operator<T, R> {
    private project;
    private concurrent;
    private scheduler;
    constructor(project: (value: T, index: number) => Observable<R>, concurrent: number, scheduler: Scheduler);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ExpandSubscriber<T, R> extends OuterSubscriber<T, R> {
    private project;
    private concurrent;
    private scheduler;
    private index;
    private active;
    private hasCompleted;
    private buffer;
    constructor(destination: Subscriber<R>, project: (value: T, index: number) => Observable<R>, concurrent: number, scheduler: Scheduler);
    private static dispatch<T, R>(arg);
    protected _next(value: any): void;
    private subscribeToProjection(result, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/expand' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/expand');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/expand.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/expand' {
import { ExpandSignature } from '~@reactivex/RxJS/dist/cjs/operator/expand';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        expand: ExpandSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/filter.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/filter' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctKey}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
export function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): Observable<T>;
export interface FilterSignature<T> {
    (predicate: (value: T, index: number) => boolean, thisArg?: any): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/filter' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/filter');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/filter.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/filter' {
import { FilterSignature } from '~@reactivex/RxJS/dist/cjs/operator/filter';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        filter: FilterSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/finally.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/finally' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} finallySelector function to be called when source terminates.
 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
export function _finally<T>(finallySelector: () => void): Observable<T>;
export interface FinallySignature<T> {
    <T>(finallySelector: () => void): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/finally' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/finally');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/finally.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/finally' {
import { FinallySignature } from '~@reactivex/RxJS/dist/cjs/operator/finally';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        finally: FinallySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/first.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/first' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {function(value: T, index: number): R} [resultSelector] A function to
 * produce the value on the output Observable based on the values
 * and the indices of the source Observable. The arguments passed to this
 * function are:
 * - `value`: the value that was emitted on the source.
 * - `index`: the "index" of the value from the source.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} an Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */
export function first<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<T | R>;
export interface FirstSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, resultSelector: void, defaultValue?: T): Observable<T>;
    <R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/first' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/first');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/first.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/first' {
import { FirstSignature } from '~@reactivex/RxJS/dist/cjs/operator/first';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        first: FirstSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/groupBy.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/groupBy' {
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @param {function(value: T): K} keySelector a function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] a function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * a function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} an Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): Observable<GroupedObservable<K, R>>;
export interface GroupBySignature<T> {
    <K>(keySelector: (value: T) => K): Observable<GroupedObservable<K, T>>;
    <K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): Observable<GroupedObservable<K, T>>;
    <K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): Observable<GroupedObservable<K, R>>;
}
export interface RefCountSubscription {
    count: number;
    unsubscribe: () => void;
    isUnsubscribed: boolean;
    attemptedToUnsubscribe: boolean;
}
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
export class GroupedObservable<K, T> extends Observable<T> {
    key: K;
    private groupSubject;
    private refCountSubscription;
    constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/groupBy' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/groupBy');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/groupBy.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/groupBy' {
import { GroupBySignature } from '~@reactivex/RxJS/dist/cjs/operator/groupBy';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        groupBy: GroupBySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/ignoreElements.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/ignoreElements' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} an empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */
export function ignoreElements<T>(): Observable<T>;
export interface IgnoreElementsSignature<T> {
    (): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/ignoreElements' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/ignoreElements');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/ignoreElements.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/ignoreElements' {
import { IgnoreElementsSignature } from '~@reactivex/RxJS/dist/cjs/operator/ignoreElements';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        ignoreElements: IgnoreElementsSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/audit.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/audit' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param durationSelector
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method audit
 * @owner Observable
 */
export function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): Observable<T>;
export interface AuditSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/audit' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/audit');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/audit.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/audit' {
import { AuditSignature } from '~@reactivex/RxJS/dist/cjs/operator/audit';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        audit: AuditSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/auditTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/auditTime' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param delay
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method auditTime
 * @owner Observable
 */
export function auditTime<T>(delay: number, scheduler?: Scheduler): Observable<T>;
export interface AuditTimeSignature<T> {
    (delay: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/auditTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/auditTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/auditTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/auditTime' {
import { AuditTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/auditTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        auditTime: AuditTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/last.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/last' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} predicate - the condition any source emitted item has to satisfy.
 * @return {Observable} an Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 * @method last
 * @owner Observable
 */
export function last<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R | void, defaultValue?: R): Observable<T | R>;
export interface LastSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, resultSelector: void, defaultValue?: T): Observable<T>;
    <R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: (value: T, index: number) => R, defaultValue?: R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/last' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/last');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/last.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/last' {
import { LastSignature } from '~@reactivex/RxJS/dist/cjs/operator/last';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        last: LastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/let.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/let' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param func
 * @return {Observable<R>}
 * @method let
 * @owner Observable
 */
export function letProto<T, R>(func: (selector: Observable<T>) => Observable<R>): Observable<R>;
export interface LetSignature<T> {
    <R>(func: (selector: Observable<T>) => Observable<R>): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/let' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/let');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/let.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/let' {
import { LetSignature } from '~@reactivex/RxJS/dist/cjs/operator/let';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        let: LetSignature<T>;
        letBind: LetSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/every.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/every' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 * @param {function} predicate a function for determining if an item meets a specified condition.
 * @param {any} [thisArg] optional object to use for `this` in the callback
 * @return {Observable} an Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */
export function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;
export interface EverySignature<T> {
    (predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/every' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/every');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/every.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/every' {
import { EverySignature } from '~@reactivex/RxJS/dist/cjs/operator/every';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        every: EverySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/map.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/map' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
export function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): Observable<R>;
export interface MapSignature<T> {
    <R>(project: (value: T, index: number) => R, thisArg?: any): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/map' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/map');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/map.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/map' {
import { MapSignature } from '~@reactivex/RxJS/dist/cjs/operator/map';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        map: MapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/mapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/mapTo' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */
export function mapTo<T, R>(value: R): Observable<R>;
export interface MapToSignature<T> {
    <R>(value: R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/mapTo' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/mapTo');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/mapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/mapTo' {
import { MapToSignature } from '~@reactivex/RxJS/dist/cjs/operator/mapTo';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        mapTo: MapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/materialize.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/materialize' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Notification } from '~@reactivex/RxJS/dist/cjs/Notification';
/**
 * Returns an Observable that represents all of the emissions and notifications
 * from the source Observable into emissions marked with their original types
 * within a `Notification` objects.
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * @see {@link Notification}
 *
 * @scheduler materialize does not operate by default on a particular Scheduler.
 * @return {Observable<Notification<T>>} an Observable that emits items that are the result of
 * materializing the items and notifications of the source Observable.
 * @method materialize
 * @owner Observable
 */
export function materialize<T>(): Observable<Notification<T>>;
export interface MaterializeSignature<T> {
    (): Observable<Notification<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/materialize' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/materialize');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/materialize.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/materialize' {
import { MaterializeSignature } from '~@reactivex/RxJS/dist/cjs/operator/materialize';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        materialize: MaterializeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/merge.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/merge' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {Observable} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
export function merge<T, R>(...observables: Array<ObservableInput<any> | Scheduler | number>): Observable<R>;
export interface MergeSignature<T> {
    (scheduler?: Scheduler): Observable<T>;
    (concurrent?: number, scheduler?: Scheduler): Observable<T>;
    <T2>(v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
    <T2>(v2: ObservableInput<T2>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
    (...observables: Array<ObservableInput<T> | Scheduler | number>): Observable<T>;
    <R>(...observables: Array<ObservableInput<any> | Scheduler | number>): Observable<R>;
}
export function mergeStatic<T>(v1: ObservableInput<T>, scheduler?: Scheduler): Observable<T>;
export function mergeStatic<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: Scheduler): Observable<T>;
export function mergeStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: Scheduler): Observable<T | T2>;
export function mergeStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2>;
export function mergeStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function mergeStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3>;
export function mergeStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function mergeStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4>;
export function mergeStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function mergeStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5>;
export function mergeStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function mergeStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: Scheduler): Observable<T | T2 | T3 | T4 | T5 | T6>;
export function mergeStatic<T>(...observables: (ObservableInput<T> | Scheduler | number)[]): Observable<T>;
export function mergeStatic<T, R>(...observables: (ObservableInput<any> | Scheduler | number)[]): Observable<R>;
}
declare module '@reactivex/RxJS/dist/cjs/operator/merge' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/merge');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/merge.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/merge' {
import { MergeSignature } from '~@reactivex/RxJS/dist/cjs/operator/merge';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        merge: MergeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/mergeAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/mergeAll' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Observer } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
export function mergeAll<T>(concurrent?: number): T;
export interface MergeAllSignature<T> {
    (concurrent?: number): T;
}
export class MergeAllOperator<T> implements Operator<Observable<T>, T> {
    private concurrent;
    constructor(concurrent: number);
    call(observer: Observer<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeAllSubscriber<T> extends OuterSubscriber<Observable<T>, T> {
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    constructor(destination: Observer<T>, concurrent: number);
    protected _next(observable: Observable<T>): void;
    protected _complete(): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/mergeAll' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/mergeAll');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/mergeAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/mergeAll' {
import { MergeAllSignature } from '~@reactivex/RxJS/dist/cjs/operator/mergeAll';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        mergeAll: MergeAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/mergeMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/mergeMap' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
export function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number, concurrent?: number): Observable<R>;
export interface MergeMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): Observable<R>;
}
export class MergeMapOperator<T, I, R> implements Operator<T, I> {
    private project;
    private resultSelector;
    private concurrent;
    constructor(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    call(observer: Subscriber<I>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {
    private project;
    private resultSelector;
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    protected index: number;
    constructor(destination: Subscriber<I>, project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    protected _next(value: any): void;
    protected _tryNext(value: any): void;
    private _innerSub(ish, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, I>): void;
    _notifyResultSelector(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/mergeMap' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/mergeMap');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/mergeMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/mergeMap' {
import { MergeMapSignature } from '~@reactivex/RxJS/dist/cjs/operator/mergeMap';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        flatMap: MergeMapSignature<T>;
        mergeMap: MergeMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/mergeMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/mergeMapTo' {
import { Observable, ObservableInput, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { OuterSubscriber } from '~@reactivex/RxJS/dist/cjs/OuterSubscriber';
import { InnerSubscriber } from '~@reactivex/RxJS/dist/cjs/InnerSubscriber';
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable.
 * @method mergeMapTo
 * @owner Observable
 */
export function mergeMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number, concurrent?: number): Observable<R>;
export interface MergeMapToSignature<T> {
    <R>(observable: ObservableInput<R>, concurrent?: number): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): Observable<R>;
}
export class MergeMapToOperator<T, I, R> implements Operator<Observable<T>, R> {
    private ish;
    private resultSelector;
    private concurrent;
    constructor(ish: SubscribableOrPromise<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    call(observer: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class MergeMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {
    private ish;
    private resultSelector;
    private concurrent;
    private hasCompleted;
    private buffer;
    private active;
    protected index: number;
    constructor(destination: Subscriber<R>, ish: SubscribableOrPromise<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number);
    protected _next(value: any): void;
    private _innerSub(ish, destination, resultSelector, value, index);
    protected _complete(): void;
    notifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, I>): void;
    private trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
    notifyError(err: any): void;
    notifyComplete(innerSub: Subscription): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/mergeMapTo' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/mergeMapTo');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/mergeMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/mergeMapTo' {
import { MergeMapToSignature } from '~@reactivex/RxJS/dist/cjs/operator/mergeMapTo';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        flatMapTo: MergeMapToSignature<T>;
        mergeMapTo: MergeMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/multicast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/multicast' {
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
import { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function} selector - a function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} an Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
export function multicast<T>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>)): ConnectableObservable<T>;
export type factoryOrValue<T> = T | (() => T);
export interface MulticastSignature<T> {
    (subjectOrSubjectFactory: factoryOrValue<Subject<T>>): ConnectableObservable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/multicast' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/multicast');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/multicast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/multicast' {
import { MulticastSignature } from '~@reactivex/RxJS/dist/cjs/operator/multicast';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        multicast: MulticastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/observeOn.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/observeOn' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { PartialObserver } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Notification } from '~@reactivex/RxJS/dist/cjs/Notification';
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
export function observeOn<T>(scheduler: Scheduler, delay?: number): Observable<T>;
export interface ObserveOnSignature<T> {
    (scheduler: Scheduler, delay?: number): Observable<T>;
}
export class ObserveOnOperator<T> implements Operator<T, T> {
    private scheduler;
    private delay;
    constructor(scheduler: Scheduler, delay?: number);
    call(subscriber: Subscriber<T>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ObserveOnSubscriber<T> extends Subscriber<T> {
    private scheduler;
    private delay;
    static dispatch(arg: ObserveOnMessage): void;
    constructor(destination: Subscriber<T>, scheduler: Scheduler, delay?: number);
    private scheduleMessage(notification);
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
}
export class ObserveOnMessage {
    notification: Notification<any>;
    destination: PartialObserver<any>;
    constructor(notification: Notification<any>, destination: PartialObserver<any>);
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/observeOn' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/observeOn');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/observeOn.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/observeOn' {
import { ObserveOnSignature } from '~@reactivex/RxJS/dist/cjs/operator/observeOn';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        observeOn: ObserveOnSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/partition.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/partition' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param predicate
 * @param thisArg
 * @return {Observable<T>[]}
 * @method partition
 * @owner Observable
 */
export function partition<T>(predicate: (value: T) => boolean, thisArg?: any): [Observable<T>, Observable<T>];
export interface PartitionSignature<T> {
    (predicate: (value: T) => boolean, thisArg?: any): [Observable<T>, Observable<T>];
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/partition' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/partition');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/partition.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/partition' {
import { PartitionSignature } from '~@reactivex/RxJS/dist/cjs/operator/partition';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        partition: PartitionSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/pluck.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/pluck' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} Returns a new Observable of property values from the
 * source values.
 * @method pluck
 * @owner Observable
 */
export function pluck<R>(...properties: string[]): Observable<R>;
export interface PluckSignature<T> {
    <R>(...properties: string[]): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/pluck' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/pluck');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/pluck.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/pluck' {
import { PluckSignature } from '~@reactivex/RxJS/dist/cjs/operator/pluck';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        pluck: PluckSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/publish.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/publish' {
import { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @return a ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */
export function publish<T>(): ConnectableObservable<T>;
export interface PublishSignature<T> {
    (): ConnectableObservable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/publish' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/publish');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/publish.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/publish' {
import { PublishSignature } from '~@reactivex/RxJS/dist/cjs/operator/publish';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        publish: PublishSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/publishBehavior.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/publishBehavior' {
import { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */
export function publishBehavior<T>(value: T): ConnectableObservable<T>;
export interface PublishBehaviorSignature<T> {
    (value: T): ConnectableObservable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/publishBehavior' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/publishBehavior');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/publishBehavior.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/publishBehavior' {
import { PublishBehaviorSignature } from '~@reactivex/RxJS/dist/cjs/operator/publishBehavior';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        publishBehavior: PublishBehaviorSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/publishReplay.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/publishReplay' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
/**
 * @param bufferSize
 * @param windowTime
 * @param scheduler
 * @return {ConnectableObservable<T>}
 * @method publishReplay
 * @owner Observable
 */
export function publishReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: Scheduler): ConnectableObservable<T>;
export interface PublishReplaySignature<T> {
    (bufferSize?: number, windowTime?: number, scheduler?: Scheduler): ConnectableObservable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/publishReplay' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/publishReplay');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/publishReplay.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/publishReplay' {
import { PublishReplaySignature } from '~@reactivex/RxJS/dist/cjs/operator/publishReplay';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        publishReplay: PublishReplaySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/publishLast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/publishLast' {
import { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
/**
 * @return {ConnectableObservable<T>}
 * @method publishLast
 * @owner Observable
 */
export function publishLast<T>(): ConnectableObservable<T>;
export interface PublishLastSignature<T> {
    (): ConnectableObservable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/publishLast' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/publishLast');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/publishLast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/publishLast' {
import { PublishLastSignature } from '~@reactivex/RxJS/dist/cjs/operator/publishLast';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        publishLast: PublishLastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/race.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/race' {
import { RaceSignature } from '~@reactivex/RxJS/dist/cjs/operator/race';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        race: RaceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/reduce.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/reduce' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * Returns an Observable that applies a specified accumulator function to the first item emitted by a source Observable,
 * then feeds the result of that function along with the second item emitted by the source Observable into the same
 * function, and so on until all items have been emitted by the source Observable, and emits the final result from
 * the final call to your function as its sole item.
 * This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate," "compress," or
 * "inject" in other programming contexts.
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * @param {initialValue} the initial (seed) accumulator value
 * @param {accumulator} an accumulator function to be invoked on each item emitted by the source Observable, the
 * result of which will be used in the next accumulator call.
 * @return {Observable} an Observable that emits a single item that is the result of accumulating the output from the
 * items emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */
export function reduce<T, R>(project: (acc: R, value: T) => R, seed?: R): Observable<R>;
export interface ReduceSignature<T> {
    <R>(project: (acc: R, value: T) => R, seed?: R): Observable<R>;
}
export class ReduceOperator<T, R> implements Operator<T, R> {
    private project;
    private seed;
    constructor(project: (acc: R, value: T) => R, seed?: R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ReduceSubscriber<T, R> extends Subscriber<T> {
    acc: T | R;
    hasSeed: boolean;
    hasValue: boolean;
    project: (acc: R, value: T) => R;
    constructor(destination: Subscriber<R>, project: (acc: R, value: T) => R, seed?: R);
    protected _next(value: T): void;
    private _tryReduce(value);
    protected _complete(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/reduce' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/reduce');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/reduce.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/reduce' {
import { ReduceSignature } from '~@reactivex/RxJS/dist/cjs/operator/reduce';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        reduce: ReduceSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/repeat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/repeat' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times,
 * on a particular Scheduler.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {Scheduler} [scheduler] the Scheduler to emit the items on.
 * @param {number} [count] the number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} an Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */
export function repeat<T>(count?: number): Observable<T>;
export interface RepeatSignature<T> {
    (count?: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/repeat' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/repeat');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/repeat.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/repeat' {
import { RepeatSignature } from '~@reactivex/RxJS/dist/cjs/operator/repeat';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        repeat: RepeatSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/retry.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/retry' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that mirrors the source Observable, resubscribing to it if it calls `error` and the
 * predicate returns true for that specific exception and retry count.
 * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of
 * count resubscriptions (given as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} number of retry attempts before failing.
 * @return {Observable} the source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
export function retry<T>(count?: number): Observable<T>;
export interface RetrySignature<T> {
    (count?: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/retry' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/retry');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/retry.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/retry' {
import { RetrySignature } from '~@reactivex/RxJS/dist/cjs/operator/retry';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        retry: RetrySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/retryWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/retryWhen' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits the same values as the source observable with the exception of an `error`.
 * An `error` will cause the emission of the Throwable that cause the error to the Observable returned from
 * notificationHandler. If that Observable calls onComplete or `error` then retry will call `complete` or `error`
 * on the child subscription. Otherwise, this Observable will resubscribe to the source observable, on a particular
 * Scheduler.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {notificationHandler} receives an Observable of notifications with which a user can `complete` or `error`,
 * aborting the retry.
 * @param {scheduler} the Scheduler on which to subscribe to the source Observable.
 * @return {Observable} the source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
export function retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): Observable<T>;
export interface RetryWhenSignature<T> {
    (notifier: (errors: Observable<any>) => Observable<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/retryWhen' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/retryWhen');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/retryWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/retryWhen' {
import { RetryWhenSignature } from '~@reactivex/RxJS/dist/cjs/operator/retryWhen';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        retryWhen: RetryWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/sample.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/sample' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that, when the specified sampler Observable emits an item or completes, it then emits the most
 * recently emitted item (if any) emitted by the source Observable since the previous emission from the sampler
 * Observable.
 *
 * <img src="./img/sample.png" width="100%">
 *
 * @param {Observable} sampler - the Observable to use for sampling the source Observable.
 * @return {Observable<T>} an Observable that emits the results of sampling the items emitted by this Observable
 * whenever the sampler Observable emits an item or completes.
 * @method sample
 * @owner Observable
 */
export function sample<T>(notifier: Observable<any>): Observable<T>;
export interface SampleSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/sample' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/sample');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/sample.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/sample' {
import { SampleSignature } from '~@reactivex/RxJS/dist/cjs/operator/sample';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        sample: SampleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/sampleTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/sampleTime' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * @param delay
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method sampleTime
 * @owner Observable
 */
export function sampleTime<T>(delay: number, scheduler?: Scheduler): Observable<T>;
export interface SampleTimeSignature<T> {
    (delay: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/sampleTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/sampleTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/sampleTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/sampleTime' {
import { SampleTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/sampleTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        sampleTime: SampleTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/scan.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/scan' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Applies an accumulation function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T): R} accumulator The accumulator function
 * called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */
export function scan<T, R>(accumulator: (acc: R, value: T) => R, seed?: T | R): Observable<R>;
export interface ScanSignature<T> {
    <R>(accumulator: (acc: R, value: T) => R, seed?: T | R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/scan' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/scan');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/scan.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/scan' {
import { ScanSignature } from '~@reactivex/RxJS/dist/cjs/operator/scan';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        scan: ScanSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/share.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/share' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} an Observable that upon connection causes the source Observable to emit items to its Observers
 * @method share
 * @owner Observable
 */
export function share<T>(): Observable<T>;
export interface ShareSignature<T> {
    (): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/share' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/share');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/share.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/share' {
import { ShareSignature } from '~@reactivex/RxJS/dist/cjs/operator/share';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        share: ShareSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/single.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/single' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} a predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches
 * the predicate.
 .
 * @method single
 * @owner Observable
 */
export function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
export interface SingleSignature<T> {
    (predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/single' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/single');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/single.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/single' {
import { SingleSignature } from '~@reactivex/RxJS/dist/cjs/operator/single';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        single: SingleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/skip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/skip' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that skips `n` items emitted by an Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} the `n` of times, items emitted by source Observable should be skipped.
 * @return {Observable} an Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */
export function skip<T>(total: number): Observable<T>;
export interface SkipSignature<T> {
    (total: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/skip' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/skip');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/skip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/skip' {
import { SkipSignature } from '~@reactivex/RxJS/dist/cjs/operator/skip';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        skip: SkipSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/skipUntil.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/skipUntil' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} the second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} an Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */
export function skipUntil<T>(notifier: Observable<any>): Observable<T>;
export interface SkipUntilSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/skipUntil' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/skipUntil');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/skipUntil.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/skipUntil' {
import { SkipUntilSignature } from '~@reactivex/RxJS/dist/cjs/operator/skipUntil';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        skipUntil: SkipUntilSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/skipWhile.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/skipWhile' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - a function to test each item emitted from the source Observable.
 * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */
export function skipWhile<T>(predicate: (value: T, index: number) => boolean): Observable<T>;
export interface SkipWhileSignature<T> {
    (predicate: (value: T, index: number) => boolean): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/skipWhile' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/skipWhile');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/skipWhile.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/skipWhile' {
import { SkipWhileSignature } from '~@reactivex/RxJS/dist/cjs/operator/skipWhile';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        skipWhile: SkipWhileSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/startWith.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/startWith' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
 * source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
export function startWith<T>(...array: Array<T | Scheduler>): Observable<T>;
export interface StartWithSignature<T> {
    (v1: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: Scheduler): Observable<T>;
    (v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: Scheduler): Observable<T>;
    (...array: Array<T | Scheduler>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/startWith' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/startWith');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/startWith.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/startWith' {
import { StartWithSignature } from '~@reactivex/RxJS/dist/cjs/operator/startWith';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        startWith: StartWithSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/subscribeOn.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/subscribeOn' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Asynchronously subscribes Observers to this Observable on the specified Scheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} the Scheduler to perform subscription actions on.
 * @return {Observable<T>} the source Observable modified so that its subscriptions happen on the specified Scheduler
 .
 * @method subscribeOn
 * @owner Observable
 */
export function subscribeOn<T>(scheduler: Scheduler, delay?: number): Observable<T>;
export interface SubscribeOnSignature<T> {
    (scheduler: Scheduler, delay?: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/subscribeOn' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/subscribeOn');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/subscribeOn.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/subscribeOn' {
import { SubscribeOnSignature } from '~@reactivex/RxJS/dist/cjs/operator/subscribeOn';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        subscribeOn: SubscribeOnSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/switch.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/switch' {
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
export function _switch<T>(): T;
export interface SwitchSignature<T> {
    (): T;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/switch' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/switch');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/switch.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/switch' {
import { SwitchSignature } from '~@reactivex/RxJS/dist/cjs/operator/switch';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        switch: SwitchSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/switchMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/switchMap' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): Observable} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
export function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface SwitchMapSignature<T> {
    <R>(project: (value: T, index: number) => ObservableInput<R>): Observable<R>;
    <I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/switchMap' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/switchMap');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/switchMap.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/switchMap' {
import { SwitchMapSignature } from '~@reactivex/RxJS/dist/cjs/operator/switchMap';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        switchMap: SwitchMapSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/switchMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/switchMapTo' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {Observable} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` every time a value is emitted on the source Observable.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */
export function switchMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
export interface SwitchMapToSignature<T> {
    <R>(observable: ObservableInput<R>): Observable<R>;
    <I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/switchMapTo' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/switchMapTo');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/switchMapTo.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/switchMapTo' {
import { SwitchMapToSignature } from '~@reactivex/RxJS/dist/cjs/operator/switchMapTo';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        switchMapTo: SwitchMapToSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/take.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/take' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 * @param total
 * @return {any}
 * @method take
 * @owner Observable
 */
export function take<T>(total: number): Observable<T>;
export interface TakeSignature<T> {
    (total: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/take' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/take');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/take.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/take' {
import { TakeSignature } from '~@reactivex/RxJS/dist/cjs/operator/take';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        take: TakeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/takeLast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/takeLast' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 * @param total
 * @return {any}
 * @method takeLast
 * @owner Observable
 */
export function takeLast<T>(total: number): Observable<T>;
export interface TakeLastSignature<T> {
    (total: number): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/takeLast' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/takeLast');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/takeLast.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/takeLast' {
import { TakeLastSignature } from '~@reactivex/RxJS/dist/cjs/operator/takeLast';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        takeLast: TakeLastSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/takeUntil.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/takeUntil' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param notifier
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method takeUntil
 * @owner Observable
 */
export function takeUntil<T>(notifier: Observable<any>): Observable<T>;
export interface TakeUntilSignature<T> {
    (notifier: Observable<any>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/takeUntil' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/takeUntil');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/takeUntil.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/takeUntil' {
import { TakeUntilSignature } from '~@reactivex/RxJS/dist/cjs/operator/takeUntil';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        takeUntil: TakeUntilSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/takeWhile.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/takeWhile' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param predicate
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method takeWhile
 * @owner Observable
 */
export function takeWhile<T>(predicate: (value: T, index: number) => boolean): Observable<T>;
export interface TakeWhileSignature<T> {
    (predicate: (value: T, index: number) => boolean): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/takeWhile' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/takeWhile');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/takeWhile.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/takeWhile' {
import { TakeWhileSignature } from '~@reactivex/RxJS/dist/cjs/operator/takeWhile';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        takeWhile: TakeWhileSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/throttle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/throttle' {
import { Observable, SubscribableOrPromise } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param durationSelector
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method throttle
 * @owner Observable
 */
export function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
export interface ThrottleSignature<T> {
    (durationSelector: (value: T) => SubscribableOrPromise<number>): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/throttle' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/throttle');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/throttle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/throttle' {
import { ThrottleSignature } from '~@reactivex/RxJS/dist/cjs/operator/throttle';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        throttle: ThrottleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/throttleTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/throttleTime' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param delay
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method throttleTime
 * @owner Observable
 */
export function throttleTime<T>(delay: number, scheduler?: Scheduler): Observable<T>;
export interface ThrottleTimeSignature<T> {
    (dueTime: number, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/throttleTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/throttleTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/throttleTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/throttleTime' {
import { ThrottleTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/throttleTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        throttleTime: ThrottleTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/timeout.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/timeout' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param due
 * @param errorToSend
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeout
 * @owner Observable
 */
export function timeout<T>(due: number | Date, errorToSend?: any, scheduler?: Scheduler): Observable<T>;
export interface TimeoutSignature<T> {
    (due: number | Date, errorToSend?: any, scheduler?: Scheduler): Observable<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/timeout' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/timeout');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/timeout.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/timeout' {
import { TimeoutSignature } from '~@reactivex/RxJS/dist/cjs/operator/timeout';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        timeout: TimeoutSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/timeoutWith.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/timeoutWith' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param due
 * @param withObservable
 * @param scheduler
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method timeoutWith
 * @owner Observable
 */
export function timeoutWith<T, R>(due: number | Date, withObservable: Observable<R>, scheduler?: Scheduler): Observable<T | R>;
export interface TimeoutWithSignature<T> {
    (due: number | Date, withObservable: Observable<T>, scheduler?: Scheduler): Observable<T>;
    <R>(due: number | Date, withObservable: Observable<R>, scheduler?: Scheduler): Observable<T | R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/timeoutWith' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/timeoutWith');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/timeoutWith.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/timeoutWith' {
import { TimeoutWithSignature } from '~@reactivex/RxJS/dist/cjs/operator/timeoutWith';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        timeoutWith: TimeoutWithSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/toArray.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/toArray' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
 * @method toArray
 * @owner Observable
 */
export function toArray<T>(): Observable<T[]>;
export interface ToArraySignature<T> {
    (): Observable<T[]>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/toArray' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/toArray');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/toArray.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/toArray' {
import { ToArraySignature } from '~@reactivex/RxJS/dist/cjs/operator/toArray';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        toArray: ToArraySignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/toPromise.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/toPromise' {
/**
 * @param PromiseCtor
 * @return {Promise<T>}
 * @method toPromise
 * @owner Observable
 */
export function toPromise<T>(PromiseCtor?: typeof Promise): Promise<T>;
export interface ToPromiseSignature<T> {
    (): Promise<T>;
    (PromiseCtor: typeof Promise): Promise<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/toPromise' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/toPromise');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/toPromise.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/toPromise' {
import { ToPromiseSignature } from '~@reactivex/RxJS/dist/cjs/operator/toPromise';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        toPromise: ToPromiseSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/window.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/window' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */
export function window<T>(windowBoundaries: Observable<any>): Observable<Observable<T>>;
export interface WindowSignature<T> {
    (windowBoundaries: Observable<any>): Observable<Observable<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/window' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/window');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/window.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/window' {
import { WindowSignature } from '~@reactivex/RxJS/dist/cjs/operator/window';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        window: WindowSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/windowCount.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/windowCount' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */
export function windowCount<T>(windowSize: number, startWindowEvery?: number): Observable<Observable<T>>;
export interface WindowCountSignature<T> {
    (windowSize: number, startWindowEvery?: number): Observable<Observable<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/windowCount' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/windowCount');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/windowCount.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/windowCount' {
import { WindowCountSignature } from '~@reactivex/RxJS/dist/cjs/operator/windowCount';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        windowCount: WindowCountSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/windowTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/windowTime' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
/**
 * Branch out the source Observable values as a nested Observable periodically
 * in time.
 *
 * <span class="informal">It's like {@link bufferTime}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowTime.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable starts a new window periodically, as
 * determined by the `windowCreationInterval` argument. It emits each window
 * after a fixed timespan, specified by the `windowTimeSpan` argument. When the
 * source Observable completes or encounters an error, the output Observable
 * emits the current window and propagates the notification from the source
 * Observable. If `windowCreationInterval` is not provided, the output
 * Observable starts a new window when the previous window of duration
 * `windowTimeSpan` completes.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowTime(1000, 5000)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferTime}
 *
 * @param {number} windowTimeSpan The amount of time to fill each window.
 * @param {number} [windowCreationInterval] The interval at which to start new
 * windows.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine window boundaries.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowTime
 * @owner Observable
 */
export function windowTime<T>(windowTimeSpan: number, windowCreationInterval?: number, scheduler?: Scheduler): Observable<Observable<T>>;
export interface WindowTimeSignature<T> {
    (windowTimeSpan: number, windowCreationInterval?: number, scheduler?: Scheduler): Observable<Observable<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/windowTime' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/windowTime');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/windowTime.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/windowTime' {
import { WindowTimeSignature } from '~@reactivex/RxJS/dist/cjs/operator/windowTime';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        windowTime: WindowTimeSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/windowToggle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/windowToggle' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
export function windowToggle<T, O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): Observable<Observable<T>>;
export interface WindowToggleSignature<T> {
    <O>(openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): Observable<Observable<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/windowToggle' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/windowToggle');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/windowToggle.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/windowToggle' {
import { WindowToggleSignature } from '~@reactivex/RxJS/dist/cjs/operator/windowToggle';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        windowToggle: WindowToggleSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/windowWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/windowWhen' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
export function windowWhen<T>(closingSelector: () => Observable<any>): Observable<Observable<T>>;
export interface WindowWhenSignature<T> {
    (closingSelector: () => Observable<any>): Observable<Observable<T>>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/windowWhen' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/windowWhen');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/windowWhen.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/windowWhen' {
import { WindowWhenSignature } from '~@reactivex/RxJS/dist/cjs/operator/windowWhen';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        windowWhen: WindowWhenSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/withLatestFrom.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/withLatestFrom' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {Observable} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
export function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export interface WithLatestFromSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    <R>(array: ObservableInput<any>[]): Observable<R>;
    <R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/withLatestFrom' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/withLatestFrom');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/withLatestFrom.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/withLatestFrom' {
import { WithLatestFromSignature } from '~@reactivex/RxJS/dist/cjs/operator/withLatestFrom';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        withLatestFrom: WithLatestFromSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/zip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/zip' {
import { Observable, ObservableInput } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
export function zipProto<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export interface ZipSignature<T> {
    <R>(project: (v1: T) => R): Observable<R>;
    <T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
    <T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
    <T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
    <T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
    <T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
    <T2>(v2: ObservableInput<T2>): Observable<[T, T2]>;
    <T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
    <T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
    <T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
    <T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
    <R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
    <R>(array: ObservableInput<any>[]): Observable<R>;
    <R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
}
export function zipStatic<T>(v1: ObservableInput<T>): Observable<[T]>;
export function zipStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
export function zipStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
export function zipStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
export function zipStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
export function zipStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
export function zipStatic<T, R>(v1: ObservableInput<T>, project: (v1: T) => R): Observable<R>;
export function zipStatic<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;
export function zipStatic<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
export function zipStatic<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
export function zipStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export function zipStatic<R>(array: ObservableInput<any>[]): Observable<R>;
export function zipStatic<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;
export class ZipOperator<T, R> implements Operator<T, R> {
    project: (...values: Array<any>) => R;
    constructor(project?: (...values: Array<any>) => R);
    call(subscriber: Subscriber<R>, source: any): any;
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class ZipSubscriber<T, R> extends Subscriber<T> {
    private index;
    private values;
    private project;
    private iterators;
    private active;
    constructor(destination: Subscriber<R>, project?: (...values: Array<any>) => R, values?: any);
    protected _next(value: any): void;
    protected _complete(): void;
    notifyInactive(): void;
    checkIterators(): void;
    protected _tryProject(args: any[]): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/zip' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/zip');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/zip.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/zip' {
import { ZipSignature } from '~@reactivex/RxJS/dist/cjs/operator/zip';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        zip: ZipSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/operator/zipAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/operator/zipAll' {
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * @param project
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method zipAll
 * @owner Observable
 */
export function zipAll<T, R>(project?: (...values: Array<any>) => R): Observable<R>;
export interface ZipAllSignature<T> {
    (): Observable<T[]>;
    <R>(project?: (...values: Array<T>) => R): Observable<R>;
}
}
declare module '@reactivex/RxJS/dist/cjs/operator/zipAll' {
import alias = require('~@reactivex/RxJS/dist/cjs/operator/zipAll');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/add/operator/zipAll.d.ts
declare module '~@reactivex/RxJS/dist/cjs/add/operator/zipAll' {
import { ZipAllSignature } from '~@reactivex/RxJS/dist/cjs/operator/zipAll';
module '~@reactivex/RxJS/dist/cjs/Observable' {
    interface Observable<T> {
        zipAll: ZipAllSignature<T>;
    }
}
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Operator.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Operator' {
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
export class Operator<T, R> {
    call(subscriber: Subscriber<R>, source: any): any;
}
}
declare module '@reactivex/RxJS/dist/cjs/Operator' {
import alias = require('~@reactivex/RxJS/dist/cjs/Operator');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Observer.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Observer' {
export interface NextObserver<T> {
    isUnsubscribed?: boolean;
    next: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
export interface ErrorObserver<T> {
    isUnsubscribed?: boolean;
    next?: (value: T) => void;
    error: (err: any) => void;
    complete?: () => void;
}
export interface CompletionObserver<T> {
    isUnsubscribed?: boolean;
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete: () => void;
}
export type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
export interface Observer<T> {
    isUnsubscribed?: boolean;
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
export const empty: Observer<any>;
}
declare module '@reactivex/RxJS/dist/cjs/Observer' {
import alias = require('~@reactivex/RxJS/dist/cjs/Observer');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Subscription.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Subscription' {
export interface AnonymousSubscription {
    unsubscribe(): void;
}
export type TeardownLogic = AnonymousSubscription | Function | void;
export interface ISubscription extends AnonymousSubscription {
    unsubscribe(): void;
    isUnsubscribed: boolean;
    add(teardown: TeardownLogic): ISubscription;
    remove(sub: ISubscription): void;
}
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
export class Subscription implements ISubscription {
    static EMPTY: Subscription;
    /**
     * A flag to indicate whether this Subscription has already been unsubscribed.
     * @type {boolean}
     */
    isUnsubscribed: boolean;
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    constructor(unsubscribe?: () => void);
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    unsubscribe(): void;
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `isUnsubscribed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    add(teardown: TeardownLogic): Subscription;
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    remove(subscription: Subscription): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/Subscription' {
import alias = require('~@reactivex/RxJS/dist/cjs/Subscription');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Subscriber.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Subscriber' {
import { Observer, PartialObserver } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
export class Subscriber<T> extends Subscription implements Observer<T> {
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;
    syncErrorValue: any;
    syncErrorThrown: boolean;
    syncErrorThrowable: boolean;
    protected isStopped: boolean;
    protected destination: PartialObserver<any>;
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    next(value?: T): void;
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    error(err?: any): void;
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    complete(): void;
    unsubscribe(): void;
    protected _next(value: T): void;
    protected _error(err: any): void;
    protected _complete(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/Subscriber' {
import alias = require('~@reactivex/RxJS/dist/cjs/Subscriber');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/AsyncSubject.d.ts
declare module '~@reactivex/RxJS/dist/cjs/AsyncSubject' {
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * @class AsyncSubject<T>
 */
export class AsyncSubject<T> extends Subject<T> {
    value: T;
    hasNext: boolean;
    protected _subscribe(subscriber: Subscriber<any>): TeardownLogic;
    protected _next(value: T): void;
    protected _complete(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/AsyncSubject' {
import alias = require('~@reactivex/RxJS/dist/cjs/AsyncSubject');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Scheduler.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Scheduler' {
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
export interface Scheduler {
    now(): number;
    schedule<T>(work: (state?: T) => Subscription | void, delay?: number, state?: T): Subscription;
    flush(): void;
    active: boolean;
    actions: Action<any>[];
    scheduledId: number;
}
}
declare module '@reactivex/RxJS/dist/cjs/Scheduler' {
import alias = require('~@reactivex/RxJS/dist/cjs/Scheduler');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/ReplaySubject.d.ts
declare module '~@reactivex/RxJS/dist/cjs/ReplaySubject' {
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * @class ReplaySubject<T>
 */
export class ReplaySubject<T> extends Subject<T> {
    private events;
    private scheduler;
    private bufferSize;
    private _windowTime;
    constructor(bufferSize?: number, windowTime?: number, scheduler?: Scheduler);
    protected _next(value: T): void;
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
    private _getNow();
    private _trimBufferThenGetEvents(now);
}
}
declare module '@reactivex/RxJS/dist/cjs/ReplaySubject' {
import alias = require('~@reactivex/RxJS/dist/cjs/ReplaySubject');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/BehaviorSubject.d.ts
declare module '~@reactivex/RxJS/dist/cjs/BehaviorSubject' {
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { TeardownLogic } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * @class BehaviorSubject<T>
 */
export class BehaviorSubject<T> extends Subject<T> {
    private _value;
    constructor(_value: T);
    getValue(): T;
    value: T;
    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;
    protected _next(value: T): void;
    protected _error(err: any): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/BehaviorSubject' {
import alias = require('~@reactivex/RxJS/dist/cjs/BehaviorSubject');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/observable/ConnectableObservable.d.ts
declare module '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable' {
import { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * @class ConnectableObservable<T>
 */
export class ConnectableObservable<T> extends Observable<T> {
    protected source: Observable<T>;
    protected subjectFactory: () => Subject<T>;
    protected subject: Subject<T>;
    protected subscription: Subscription;
    constructor(source: Observable<T>, subjectFactory: () => Subject<T>);
    protected _subscribe(subscriber: Subscriber<T>): Subscription;
    protected getSubject(): Subject<T>;
    connect(): Subscription;
    refCount(): Observable<T>;
    /**
     * This method is opened for `ConnectableSubscription`.
     * Not to call from others.
     */
    _closeSubscription(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/observable/ConnectableObservable' {
import alias = require('~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Notification.d.ts
declare module '~@reactivex/RxJS/dist/cjs/Notification' {
import { PartialObserver } from '~@reactivex/RxJS/dist/cjs/Observer';
import { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
export class Notification<T> {
    kind: string;
    value: T;
    exception: any;
    hasValue: boolean;
    constructor(kind: string, value?: T, exception?: any);
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    observe(observer: PartialObserver<T>): any;
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    toObservable(): Observable<T>;
    private static completeNotification;
    private static undefinedValueNotification;
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    static createNext<T>(value: T): Notification<T>;
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` exception.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    static createError<T>(err?: any): Notification<T>;
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    static createComplete(): Notification<any>;
}
}
declare module '@reactivex/RxJS/dist/cjs/Notification' {
import alias = require('~@reactivex/RxJS/dist/cjs/Notification');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/util/EmptyError.d.ts
declare module '~@reactivex/RxJS/dist/cjs/util/EmptyError' {
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
export class EmptyError extends Error {
    constructor();
}
}
declare module '@reactivex/RxJS/dist/cjs/util/EmptyError' {
import alias = require('~@reactivex/RxJS/dist/cjs/util/EmptyError');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/util/ArgumentOutOfRangeError.d.ts
declare module '~@reactivex/RxJS/dist/cjs/util/ArgumentOutOfRangeError' {
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
export class ArgumentOutOfRangeError extends Error {
    constructor();
}
}
declare module '@reactivex/RxJS/dist/cjs/util/ArgumentOutOfRangeError' {
import alias = require('~@reactivex/RxJS/dist/cjs/util/ArgumentOutOfRangeError');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/util/ObjectUnsubscribedError.d.ts
declare module '~@reactivex/RxJS/dist/cjs/util/ObjectUnsubscribedError' {
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
export class ObjectUnsubscribedError extends Error {
    constructor();
}
}
declare module '@reactivex/RxJS/dist/cjs/util/ObjectUnsubscribedError' {
import alias = require('~@reactivex/RxJS/dist/cjs/util/ObjectUnsubscribedError');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/util/UnsubscriptionError.d.ts
declare module '~@reactivex/RxJS/dist/cjs/util/UnsubscriptionError' {
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
export class UnsubscriptionError extends Error {
    errors: any[];
    constructor(errors: any[]);
}
}
declare module '@reactivex/RxJS/dist/cjs/util/UnsubscriptionError' {
import alias = require('~@reactivex/RxJS/dist/cjs/util/UnsubscriptionError');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/Action.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/Action' {
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
export interface Action<T> extends Subscription {
    work: (state?: T) => void | Subscription;
    state?: T;
    delay?: number;
    schedule(state?: T, delay?: number): void;
    execute(): void;
    scheduler: Scheduler;
    error: any;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/Action' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/Action');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/AsapScheduler.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/AsapScheduler' {
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { QueueScheduler } from '~@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler';
export class AsapScheduler extends QueueScheduler {
    scheduleNow<T>(work: (x?: T) => Subscription, state?: T): Action<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/AsapScheduler' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/AsapScheduler');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/AsyncScheduler.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/AsyncScheduler' {
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { QueueScheduler } from '~@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler';
export class AsyncScheduler extends QueueScheduler {
    scheduleNow<T>(work: (x?: T) => Subscription, state?: T): Action<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/AsyncScheduler' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/AsyncScheduler');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/FutureAction.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/FutureAction' {
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class FutureAction<T> extends Subscription implements Action<T> {
    scheduler: Scheduler;
    work: (x?: T) => Subscription | void;
    id: number;
    state: T;
    delay: number;
    error: any;
    private pending;
    constructor(scheduler: Scheduler, work: (x?: T) => Subscription | void);
    execute(): void;
    schedule(state?: T, delay?: number): Action<T>;
    protected _schedule(state?: T, delay?: number): Action<T>;
    protected _unsubscribe(): void;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/FutureAction' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/FutureAction');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/QueueAction.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/QueueAction' {
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
import { FutureAction } from '~@reactivex/RxJS/dist/cjs/scheduler/FutureAction';
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
export class QueueAction<T> extends FutureAction<T> {
    protected _schedule(state?: T, delay?: number): Action<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/QueueAction' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/QueueAction');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler.d.ts
declare module '~@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler' {
import { Scheduler } from '~@reactivex/RxJS/dist/cjs/Scheduler';
import { QueueAction } from '~@reactivex/RxJS/dist/cjs/scheduler/QueueAction';
import { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
import { Action } from '~@reactivex/RxJS/dist/cjs/scheduler/Action';
export class QueueScheduler implements Scheduler {
    active: boolean;
    actions: QueueAction<any>[];
    scheduledId: number;
    now(): number;
    flush(): void;
    schedule<T>(work: (x?: T) => Subscription | void, delay?: number, state?: T): Subscription;
    scheduleNow<T>(work: (x?: T) => Subscription | void, state?: T): Action<T>;
    scheduleLater<T>(work: (x?: T) => Subscription | void, delay: number, state?: T): Action<T>;
}
}
declare module '@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler' {
import alias = require('~@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler');
export = alias;
}

// Generated by typings
// Source: node_modules/@reactivex/RxJS/dist/cjs/Rx.d.ts
declare module '@reactivex/RxJS' {
export { Subject } from '~@reactivex/RxJS/dist/cjs/Subject';
export { Observable } from '~@reactivex/RxJS/dist/cjs/Observable';
import '~@reactivex/RxJS/dist/cjs/add/observable/bindCallback';
import '~@reactivex/RxJS/dist/cjs/add/observable/bindNodeCallback';
import '~@reactivex/RxJS/dist/cjs/add/observable/combineLatest';
import '~@reactivex/RxJS/dist/cjs/add/observable/concat';
import '~@reactivex/RxJS/dist/cjs/add/observable/defer';
import '~@reactivex/RxJS/dist/cjs/add/observable/empty';
import '~@reactivex/RxJS/dist/cjs/add/observable/forkJoin';
import '~@reactivex/RxJS/dist/cjs/add/observable/from';
import '~@reactivex/RxJS/dist/cjs/add/observable/fromEvent';
import '~@reactivex/RxJS/dist/cjs/add/observable/fromEventPattern';
import '~@reactivex/RxJS/dist/cjs/add/observable/fromPromise';
import '~@reactivex/RxJS/dist/cjs/add/observable/interval';
import '~@reactivex/RxJS/dist/cjs/add/observable/merge';
import '~@reactivex/RxJS/dist/cjs/add/observable/race';
import '~@reactivex/RxJS/dist/cjs/add/observable/never';
import '~@reactivex/RxJS/dist/cjs/add/observable/of';
import '~@reactivex/RxJS/dist/cjs/add/observable/range';
import '~@reactivex/RxJS/dist/cjs/add/observable/throw';
import '~@reactivex/RxJS/dist/cjs/add/observable/timer';
import '~@reactivex/RxJS/dist/cjs/add/observable/zip';
import '~@reactivex/RxJS/dist/cjs/add/operator/buffer';
import '~@reactivex/RxJS/dist/cjs/add/operator/bufferCount';
import '~@reactivex/RxJS/dist/cjs/add/operator/bufferTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/bufferToggle';
import '~@reactivex/RxJS/dist/cjs/add/operator/bufferWhen';
import '~@reactivex/RxJS/dist/cjs/add/operator/cache';
import '~@reactivex/RxJS/dist/cjs/add/operator/catch';
import '~@reactivex/RxJS/dist/cjs/add/operator/combineAll';
import '~@reactivex/RxJS/dist/cjs/add/operator/combineLatest';
import '~@reactivex/RxJS/dist/cjs/add/operator/concat';
import '~@reactivex/RxJS/dist/cjs/add/operator/concatAll';
import '~@reactivex/RxJS/dist/cjs/add/operator/concatMap';
import '~@reactivex/RxJS/dist/cjs/add/operator/concatMapTo';
import '~@reactivex/RxJS/dist/cjs/add/operator/count';
import '~@reactivex/RxJS/dist/cjs/add/operator/dematerialize';
import '~@reactivex/RxJS/dist/cjs/add/operator/debounce';
import '~@reactivex/RxJS/dist/cjs/add/operator/debounceTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/defaultIfEmpty';
import '~@reactivex/RxJS/dist/cjs/add/operator/delay';
import '~@reactivex/RxJS/dist/cjs/add/operator/delayWhen';
import '~@reactivex/RxJS/dist/cjs/add/operator/distinctUntilChanged';
import '~@reactivex/RxJS/dist/cjs/add/operator/do';
import '~@reactivex/RxJS/dist/cjs/add/operator/expand';
import '~@reactivex/RxJS/dist/cjs/add/operator/filter';
import '~@reactivex/RxJS/dist/cjs/add/operator/finally';
import '~@reactivex/RxJS/dist/cjs/add/operator/first';
import '~@reactivex/RxJS/dist/cjs/add/operator/groupBy';
import '~@reactivex/RxJS/dist/cjs/add/operator/ignoreElements';
import '~@reactivex/RxJS/dist/cjs/add/operator/audit';
import '~@reactivex/RxJS/dist/cjs/add/operator/auditTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/last';
import '~@reactivex/RxJS/dist/cjs/add/operator/let';
import '~@reactivex/RxJS/dist/cjs/add/operator/every';
import '~@reactivex/RxJS/dist/cjs/add/operator/map';
import '~@reactivex/RxJS/dist/cjs/add/operator/mapTo';
import '~@reactivex/RxJS/dist/cjs/add/operator/materialize';
import '~@reactivex/RxJS/dist/cjs/add/operator/merge';
import '~@reactivex/RxJS/dist/cjs/add/operator/mergeAll';
import '~@reactivex/RxJS/dist/cjs/add/operator/mergeMap';
import '~@reactivex/RxJS/dist/cjs/add/operator/mergeMapTo';
import '~@reactivex/RxJS/dist/cjs/add/operator/multicast';
import '~@reactivex/RxJS/dist/cjs/add/operator/observeOn';
import '~@reactivex/RxJS/dist/cjs/add/operator/partition';
import '~@reactivex/RxJS/dist/cjs/add/operator/pluck';
import '~@reactivex/RxJS/dist/cjs/add/operator/publish';
import '~@reactivex/RxJS/dist/cjs/add/operator/publishBehavior';
import '~@reactivex/RxJS/dist/cjs/add/operator/publishReplay';
import '~@reactivex/RxJS/dist/cjs/add/operator/publishLast';
import '~@reactivex/RxJS/dist/cjs/add/operator/race';
import '~@reactivex/RxJS/dist/cjs/add/operator/reduce';
import '~@reactivex/RxJS/dist/cjs/add/operator/repeat';
import '~@reactivex/RxJS/dist/cjs/add/operator/retry';
import '~@reactivex/RxJS/dist/cjs/add/operator/retryWhen';
import '~@reactivex/RxJS/dist/cjs/add/operator/sample';
import '~@reactivex/RxJS/dist/cjs/add/operator/sampleTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/scan';
import '~@reactivex/RxJS/dist/cjs/add/operator/share';
import '~@reactivex/RxJS/dist/cjs/add/operator/single';
import '~@reactivex/RxJS/dist/cjs/add/operator/skip';
import '~@reactivex/RxJS/dist/cjs/add/operator/skipUntil';
import '~@reactivex/RxJS/dist/cjs/add/operator/skipWhile';
import '~@reactivex/RxJS/dist/cjs/add/operator/startWith';
import '~@reactivex/RxJS/dist/cjs/add/operator/subscribeOn';
import '~@reactivex/RxJS/dist/cjs/add/operator/switch';
import '~@reactivex/RxJS/dist/cjs/add/operator/switchMap';
import '~@reactivex/RxJS/dist/cjs/add/operator/switchMapTo';
import '~@reactivex/RxJS/dist/cjs/add/operator/take';
import '~@reactivex/RxJS/dist/cjs/add/operator/takeLast';
import '~@reactivex/RxJS/dist/cjs/add/operator/takeUntil';
import '~@reactivex/RxJS/dist/cjs/add/operator/takeWhile';
import '~@reactivex/RxJS/dist/cjs/add/operator/throttle';
import '~@reactivex/RxJS/dist/cjs/add/operator/throttleTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/timeout';
import '~@reactivex/RxJS/dist/cjs/add/operator/timeoutWith';
import '~@reactivex/RxJS/dist/cjs/add/operator/toArray';
import '~@reactivex/RxJS/dist/cjs/add/operator/toPromise';
import '~@reactivex/RxJS/dist/cjs/add/operator/window';
import '~@reactivex/RxJS/dist/cjs/add/operator/windowCount';
import '~@reactivex/RxJS/dist/cjs/add/operator/windowTime';
import '~@reactivex/RxJS/dist/cjs/add/operator/windowToggle';
import '~@reactivex/RxJS/dist/cjs/add/operator/windowWhen';
import '~@reactivex/RxJS/dist/cjs/add/operator/withLatestFrom';
import '~@reactivex/RxJS/dist/cjs/add/operator/zip';
import '~@reactivex/RxJS/dist/cjs/add/operator/zipAll';
export { Operator } from '~@reactivex/RxJS/dist/cjs/Operator';
export { Observer } from '~@reactivex/RxJS/dist/cjs/Observer';
export { Subscription } from '~@reactivex/RxJS/dist/cjs/Subscription';
export { Subscriber } from '~@reactivex/RxJS/dist/cjs/Subscriber';
export { AsyncSubject } from '~@reactivex/RxJS/dist/cjs/AsyncSubject';
export { ReplaySubject } from '~@reactivex/RxJS/dist/cjs/ReplaySubject';
export { BehaviorSubject } from '~@reactivex/RxJS/dist/cjs/BehaviorSubject';
export { ConnectableObservable } from '~@reactivex/RxJS/dist/cjs/observable/ConnectableObservable';
export { Notification } from '~@reactivex/RxJS/dist/cjs/Notification';
export { EmptyError } from '~@reactivex/RxJS/dist/cjs/util/EmptyError';
export { ArgumentOutOfRangeError } from '~@reactivex/RxJS/dist/cjs/util/ArgumentOutOfRangeError';
export { ObjectUnsubscribedError } from '~@reactivex/RxJS/dist/cjs/util/ObjectUnsubscribedError';
export { UnsubscriptionError } from '~@reactivex/RxJS/dist/cjs/util/UnsubscriptionError';
import { AsapScheduler } from '~@reactivex/RxJS/dist/cjs/scheduler/AsapScheduler';
import { AsyncScheduler } from '~@reactivex/RxJS/dist/cjs/scheduler/AsyncScheduler';
import { QueueScheduler } from '~@reactivex/RxJS/dist/cjs/scheduler/QueueScheduler';
/**
 * @typedef {Object} Rx.Scheduler
 * @property {Scheduler} queue Schedules on a queue in the current event frame
 * (trampoline scheduler). Use this for iteration operations.
 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
 * fastest transport mechanism available, either Node.js' `process.nextTick()`
 * or Web Worker MessageChannel or setTimeout or others. Use this for
 * asynchronous conversions.
 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
 * time-based operations.
 */
let Scheduler: {
    asap: AsapScheduler;
    async: AsyncScheduler;
    queue: QueueScheduler;
};
/**
 * @typedef {Object} Rx.Symbol
 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
 * an object that has all of the traits of an Rx Subscriber, including the
 * ability to add and remove subscriptions to the subscription chain and
 * guarantees involving event triggering (can't "next" after unsubscription,
 * etc).
 * @property {Symbol|string} observable A symbol to use as a property name to
 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
 * to retrieve an iterator from an object.
 */
let Symbol: {
    rxSubscriber: any;
    observable: symbol;
    iterator: any;
};
export { Scheduler, Symbol };
}
