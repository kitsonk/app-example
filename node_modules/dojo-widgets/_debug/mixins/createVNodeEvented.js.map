{"version":3,"file":"createVNodeEvented.js","sourceRoot":"","sources":["createVNodeEvented.ts"],"names":[],"mappings":";;;;;;;;;IACA,uBAAmB,kBAAkB,CAAC,CAAA;IAEtC,8BAA+G,mCAAmC,CAAC,CAAA;IA8BnJ,IAAM,WAAW,GAAG;QACnB,aAAa;QACb,UAAU;QACV,WAAW;QACX,YAAY;QACZ,MAAM;QACN,QAAQ;QACR,OAAO;QACP,UAAU;QACV,OAAO;QACP,OAAO;QACP,SAAS;QACT,UAAU;QACV,OAAO;QACP,MAAM;QACN,WAAW;QACX,YAAY;QACZ,YAAY;QACZ,WAAW;QACX,UAAU;QACV,WAAW;QACX,SAAS;QACT,YAAY;QACZ,QAAQ;QACR,QAAQ;KACR,CAAC;IA6CF,IAAM,kBAAkB,GAAwB,uBAAa,CAAC,KAAK,CAAC;QACnE,KAAK,EAAsB;YAC1B,SAAS,EAAmB,IAAI;SAChC;QACD,UAAU,YAAC,QAAQ;YAClB,QAAQ,CAAC,SAAS,GAAG,EAAE,CAAC;QACzB,CAAC;QACD,YAAY,EAAE;YACb,MAAM,EAAE;gBACP,EAAE,YAAC,MAAM;oBACR,MAAM,CAAC,UAAU,IAAY,EAAE,QAA+C;wBAC7E,IAAM,OAAO,GAAiB,IAAI,CAAC;wBACnC,EAAE,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;4BACpC,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;4BACnB,MAAM,CAAC,WAAE,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,EAAE,+BAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;wBAC/D,CAAC;wBACD,IAAI,CAAC,CAAC;4BACL,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;wBAC7C,CAAC;oBACF,CAAC,CAAC;gBACH,CAAC;gBAED,IAAI,YAAC,MAAM;oBACV,MAAM,CAAC,UAAiC,KAAQ;wBAC/C,IAAM,OAAO,GAAiB,IAAI,CAAC;wBACnC,EAAE,CAAC,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;4BAC1C,IAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;4BACpD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gCACZ,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;4BAC7B,CAAC;wBACF,CAAC;wBACD,IAAI,CAAC,CAAC;4BACL,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;wBAC7B,CAAC;oBACF,CAAC,CAAC;gBACH,CAAC;aACD;SACD;KACD,CAAC,CAAC;IAEH;sBAAe,kBAAkB,CAAC","sourcesContent":["import { EventObject, Handle } from 'dojo-core/interfaces';\nimport { on } from 'dojo-core/aspect';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, { Evented, EventedOptions, EventedListener, resolveListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\n\nexport interface VNodeListeners {\n\t[on: string]: (ev?: TargettedEventObject) => boolean | void;\n\tontouchcancel?(ev?: TouchEvent): boolean | void;\n\tontouchend?(ev?: TouchEvent): boolean | void;\n\tontouchmove?(ev?: TouchEvent): boolean | void;\n\tontouchstart?(ev?: TouchEvent): boolean | void;\n\tonblur?(ev?: FocusEvent): boolean | void;\n\tonchange?(ev?: Event): boolean | void;\n\tonclick?(ev?: MouseEvent): boolean | void;\n\tondblclick?(ev?: MouseEvent): boolean | void;\n\tonfocus?(ev?: FocusEvent): boolean | void;\n\toninput?(ev?: Event): boolean | void;\n\tonkeydown?(ev?: KeyboardEvent): boolean | void;\n\tonkeypress?(ev?: KeyboardEvent): boolean | void;\n\tonkeyup?(ev?: KeyboardEvent): boolean | void;\n\tonload?(ev?: Event): boolean | void;\n\tonmousedown?(ev?: MouseEvent): boolean | void;\n\tonmouseenter?(ev?: MouseEvent): boolean | void;\n\tonmouseleave?(ev?: MouseEvent): boolean | void;\n\tonmousemove?(ev?: MouseEvent): boolean | void;\n\tonmouseout?(ev?: MouseEvent): boolean | void;\n\tonmouseover?(ev?: MouseEvent): boolean | void;\n\tonmouseup?(ev?: MouseEvent): boolean | void;\n\tonmousewheel?(ev?: MouseWheelEvent): boolean | void;\n\tonscroll?(ev?: UIEvent): boolean | void;\n\tonsubmit?(ev?: Event): boolean | void;\n}\n\nconst vnodeEvents = [\n\t'touchcancel',\n\t'touchend',\n\t'touchmove',\n\t'touchstart',\n\t'blur',\n\t'change',\n\t'click',\n\t'dblclick',\n\t'focus',\n\t'input',\n\t'keydown',\n\t'keypress',\n\t'keyup',\n\t'load',\n\t'mousedown',\n\t'mouseenter',\n\t'mouseleave',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'mousewheel',\n\t'scroll',\n\t'submit'\n];\n\nexport interface VNodeEventedMixin {\n\t/**\n\t * A map of listeners that are exposed for use by the virutal DOM\n\t */\n\tlisteners: VNodeListeners;\n}\n\nexport interface VNodeEventedOverrides {\n\ton(type: 'touchcancel', listener: EventedListener<TouchEvent>): Handle;\n\ton(type: 'touchend', listener: EventedListener<TouchEvent>): Handle;\n\ton(type: 'touchmove', listener: EventedListener<TouchEvent>): Handle;\n\ton(type: 'blur', listener: EventedListener<FocusEvent>): Handle;\n\ton(type: 'change', listener: EventedListener<Event>): Handle;\n\ton(type: 'click', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'dblclick', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'focus', listener: EventedListener<FocusEvent>): Handle;\n\ton(type: 'input', listener: EventedListener<Event>): Handle;\n\ton(type: 'keydown', listener: EventedListener<KeyboardEvent>): Handle;\n\ton(type: 'keypress', listener: EventedListener<KeyboardEvent>): Handle;\n\ton(type: 'keyup', listener: EventedListener<KeyboardEvent>): Handle;\n\ton(type: 'load', listener: EventedListener<Event>): Handle;\n\ton(type: 'mousedown', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mouseenter', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mouseleave', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mousemove', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mouseout', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mouseover', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mouseup', listener: EventedListener<MouseEvent>): Handle;\n\ton(type: 'mousewheel', listener: EventedListener<MouseWheelEvent>): Handle;\n\ton(type: 'scroll', listener: EventedListener<UIEvent>): Handle;\n\ton(type: 'submit', listener: EventedListener<Event>): Handle;\n\t/**\n\t * Add a listener to an event by type\n\t * @param type The type of event to listen for\n\t * @param listener The event listener to attach\n\t */\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type VNodeEvented = Evented & VNodeEventedMixin & VNodeEventedOverrides;\n\nexport interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, EventedOptions> { }\n\nconst createVNodeEvented: VNodeEventedFactory = createEvented.mixin({\n\tmixin: <VNodeEventedMixin> {\n\t\tlisteners: <VNodeListeners> null\n\t},\n\tinitialize(instance) {\n\t\tinstance.listeners = {};\n\t},\n\taspectAdvice: {\n\t\taround: {\n\t\t\ton(origFn): (type: string, listener: EventedListener<TargettedEventObject>) => Handle {\n\t\t\t\treturn function (type: string, listener: EventedListener<TargettedEventObject>): Handle {\n\t\t\t\t\tconst evented: VNodeEvented = this;\n\t\t\t\t\tif (vnodeEvents.indexOf(type) > -1) {\n\t\t\t\t\t\ttype = 'on' + type;\n\t\t\t\t\t\treturn on(evented.listeners, type, resolveListener(listener));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn origFn.call(evented, type, listener);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\temit(origFn): <T extends EventObject>(event: T) => void {\n\t\t\t\treturn function <T extends EventObject>(event: T): void {\n\t\t\t\t\tconst evented: VNodeEvented = this;\n\t\t\t\t\tif (vnodeEvents.indexOf(event.type) > -1) {\n\t\t\t\t\t\tconst method = evented.listeners['on' + event.type];\n\t\t\t\t\t\tif (method) {\n\t\t\t\t\t\t\tmethod.call(evented, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\torigFn.call(evented, event);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n});\n\nexport default createVNodeEvented;\n"]}