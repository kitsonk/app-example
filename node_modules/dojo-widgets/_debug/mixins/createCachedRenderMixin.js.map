{"version":3,"file":"createCachedRenderMixin.js","sourceRoot":"","sources":["createCachedRenderMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import { h, VNode, VNodeProperties } from 'maquette/maquette';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { State, Stateful, StatefulOptions } from 'dojo-compose/mixins/createStateful';\nimport { assign } from 'dojo-core/lang';\nimport Map from 'dojo-core/Map';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { ParentMixin, Child } from './createParentMixin';\nimport createRenderable, { Renderable } from './createRenderable';\nimport createVNodeEvented, { VNodeEvented } from './createVNodeEvented';\n\nexport type StylesHash = { [style: string]: string; };\n\nexport interface CachedRenderState extends State {\n\t/**\n\t * The ID of this widget\n\t */\n\tid?: string;\n\n\t/**\n\t * Any label text for this widget\n\t */\n\tlabel?: string;\n\n\t/**\n\t * Any classes to set at construction to the VNode\n\t */\n\tclasses?: string[];\n\n\t/**\n\t * Any styles to set at startup to the VNode\n\t */\n\tstyles?: StylesHash;\n}\n\nexport type CachedRenderParent = ParentMixin<Child> & {\n\t/**\n\t * Invalidate the widget so that it will recalculate on its next render\n\t */\n\tinvalidate(): void;\n}\n\nexport interface CachedRender {\n\t/**\n\t * Returns the node attribute properties to be used by a render function\n\t * @param overrides Any optional overrides of properties\n\t */\n\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties;\n\n\t/**\n\t * Returns any children VNodes that are part of the widget\n\t */\n\tgetChildrenNodes(): (VNode | string)[];\n\n\t/**\n\t * Invalidate the widget so that it will recalculate on its next render\n\t */\n\tinvalidate(): void;\n\n\t/**\n\t * An array of strings that represent classes to be set on the widget.  If classes are present in the state, getting and\n\t * setting classes is done on the state, otherwise they are shadowed on the instance.\n\t */\n\tclasses: string[];\n\n\trender(): VNode;\n\n\t/**\n\t * A has of styles that should be applied to root VNode of the widget.  If styles are present in the state, getting and\n\t * setting classes is done on the state, otherwiser they are shadowed on the instance.\n\t */\n\tstyles: StylesHash;\n}\n\nexport interface CachedRenderOverrides {\n\t/**\n\t * The parent of the widget\n\t */\n\tparent?: CachedRenderParent;\n}\n\nexport type CachedRenderMixin<S extends CachedRenderState> = Stateful<S> & Renderable & CachedRender & VNodeEvented & CachedRenderOverrides;\n\nexport interface CachedRenderFactory extends ComposeFactory<CachedRenderMixin<CachedRenderState>, StatefulOptions<CachedRenderState>> { }\n\n/**\n * A map of dirty flags used when determining if the render function\n * should be called\n */\nconst dirtyMap = new Map<CachedRenderMixin<CachedRenderState>, boolean>();\n\n/**\n * A weak map of the rendered VNode to return when the widget is\n * not dirty.\n */\nconst renderCache = new WeakMap<CachedRenderMixin<CachedRenderState>, VNode>();\n\n/**\n * A weak map to shadow the classes for the widget\n */\nconst shadowClasses = new WeakMap<CachedRenderMixin<CachedRenderState>, string[]>();\n\n/**\n * A weak map to shadow the styles for the widget\n */\nconst shadowStyles = new WeakMap<CachedRenderMixin<CachedRenderState>, StylesHash>();\n\nconst createCachedRenderMixin: CachedRenderFactory = createStateful\n\t.mixin(createRenderable)\n\t.mixin({\n\t\tmixin: createVNodeEvented,\n\t\tinitialize(instance: CachedRenderMixin<CachedRenderState>) {\n\t\t\tinstance.own(instance.on('statechange', () => { instance.invalidate(); } ));\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: <CachedRender> {\n\t\t\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tconst props: VNodeProperties = cachedRender.state.id ? { 'data-widget-id': cachedRender.state.id } : {};\n\t\t\t\tfor (let key in cachedRender.listeners) {\n\t\t\t\t\tprops[key] = cachedRender.listeners[key];\n\t\t\t\t}\n\t\t\t\tconst classes: { [index: string]: boolean; } = {};\n\t\t\t\tif (cachedRender.classes) {\n\t\t\t\t\tcachedRender.classes.forEach((c) => classes[c] = true);\n\t\t\t\t}\n\t\t\t\tprops.classes = classes;\n\t\t\t\tprops.styles = cachedRender.styles || {};\n\t\t\t\tprops.key = cachedRender;\n\t\t\t\tif (overrides) {\n\t\t\t\t\tassign(props, overrides);\n\t\t\t\t}\n\t\t\t\treturn props;\n\t\t\t},\n\n\t\t\tgetChildrenNodes(): (VNode | string)[] {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.label ? [ cachedRender.state.label ] : undefined;\n\t\t\t},\n\n\t\t\trender(): VNode {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tlet cached = renderCache.get(cachedRender);\n\t\t\t\tif (!dirtyMap.get(cachedRender) && cached) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcached = h(cachedRender.tagName, cachedRender.getNodeAttributes(), cachedRender.getChildrenNodes());\n\t\t\t\t\trenderCache.set(cachedRender, cached);\n\t\t\t\t\tdirtyMap.set(cachedRender, false);\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tinvalidate(): void {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (dirtyMap.get(cachedRender)) { /* short circuit if already dirty */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst parent = cachedRender.parent;\n\t\t\t\tdirtyMap.set(cachedRender, true);\n\t\t\t\trenderCache.delete(cachedRender); /* Allow GC to occur on renderCache */\n\t\t\t\tif (parent && parent.invalidate) {\n\t\t\t\t\tparent.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget classes(): string[] {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.classes || shadowClasses.get(cachedRender);\n\t\t\t},\n\n\t\t\tset classes(value: string[]) {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (cachedRender.state.classes) {\n\t\t\t\t\tcachedRender.setState({ classes: value });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tshadowClasses.set(cachedRender, value);\n\t\t\t\t\tcachedRender.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget styles(): StylesHash {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.styles || shadowStyles.get(cachedRender);\n\t\t\t},\n\n\t\t\tset styles(value: StylesHash) {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (cachedRender.state.styles) {\n\t\t\t\t\tcachedRender.setState({ styles: value });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tshadowStyles.set(cachedRender, value);\n\t\t\t\t\tcachedRender.invalidate();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinitialize(instance) {\n\t\t\t/* at this point, casting instance as the final type blows up the type inference, so the only choice is to\n\t\t\t* cast as any */\n\t\t\tdirtyMap.set(instance, true);\n\t\t\tshadowClasses.set(instance, []);\n\t\t}\n\t});\n\nexport default createCachedRenderMixin;\n"]}