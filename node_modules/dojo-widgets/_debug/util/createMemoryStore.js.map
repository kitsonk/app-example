{"version":3,"file":"createMemoryStore.js","sourceRoot":"","sources":["createMemoryStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { OrderedMap, Map } from 'immutable/immutable';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { assign } from 'dojo-core/lang';\nimport Promise, { isThenable } from 'dojo-core/Promise';\nimport WeakMap from 'dojo-core/WeakMap';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createDestroyable, { Destroyable } from 'dojo-compose/mixins/createDestroyable';\n\nexport type StoreIndex = number | string;\n\nexport interface MemoryStorePragma {\n\t/**\n\t * The identity of the object\n\t */\n\tid?: StoreIndex;\n\n\t/**\n\t * Should the item be replaced if already exists.\n\t */\n\treplace?: boolean;\n}\n\nexport interface MemoryStorePromise<T> extends Promise<T> {\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport interface MemoryStoreOptions<T extends Object> {\n\t/**\n\t * Any initial data that should populate the store\n\t */\n\tdata?: T[];\n\n\t/**\n\t * The property of each object to use as the identity for the object\n\t */\n\tidProperty?: StoreIndex;\n}\n\nexport const enum ChangeTypes {\n\tAdd = 1,\n\tPut,\n\tPatch,\n\tDelete\n}\n\nexport interface ChangeRecord<T extends Object> {\n\ttype: ChangeTypes;\n\tid: StoreIndex;\n\ttarget?: T;\n}\n\nexport interface MemoryStoreMixin<T extends Object> {\n\t/**\n\t * The property that determines the ID of the object (defaults to `id`)\n\t */\n\tidProperty: StoreIndex;\n\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\n\t/**\n\t * Observe an object, any subsequent changes to the object can also be observed via the observable\n\t * interface that is returned.  If the object is not present in the store, the observation will be\n\t * immediatly completed.  If the object is deleted from the store, the observation will be completed\n\t * @param id The ID of the object to observe\n\t */\n\tobserve(id: StoreIndex): Observable<T>;\n\tobserve(): Observable<ChangeRecord<T>>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport type MemoryStore<T extends Object> = MemoryStoreMixin<T> & Destroyable;\n\n/**\n * The weak map that contains the data for the stores\n */\nconst dataWeakMap = new WeakMap<MemoryStore<Object>, OrderedMap<StoreIndex, Object>>();\n\n/**\n * The weak map that contains any observers for the stores\n */\nconst itemObserverWeakMap = new WeakMap<MemoryStore<Object>, Map<StoreIndex, Observer<Object>[]>>();\n\n// const storeObserverWeakMap = new WeakMap<MemoryStore<Object>, Observer<ChangeRecord<Object>>[]>();\n\nexport interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {\n\t<T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;\n\n\t/**\n\t * Creates a memory store from an array of objects\n\t * @params data The array of data to create the memory store from\n\t */\n\tfromArray<T extends Object>(data: T[]): MemoryStore<T>;\n}\n\n/**\n * The methods to decorate the MemoryStorePromise with\n */\nconst storeMethods = [ 'get', 'put', 'add', 'patch', 'delete', 'fromArray' ];\n\n/**\n * Utility function that takes a result and generates a MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n */\nfunction wrapResult<R>(store: MemoryStore<Object>, result: R): MemoryStorePromise<R> {\n\t/* TODO: this all seems pretty expensive, there has to be a better way */\n\tconst p = (isThenable(result) ? result : Promise.resolve(result)) as MemoryStorePromise<R>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Utility function that takes an error and generates a rejected MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap\n */\nfunction wrapError(store: MemoryStore<Object>, result: Error): MemoryStorePromise<Object> {\n\tconst p = (isThenable(result) ? result : Promise.reject(result)) as MemoryStorePromise<Object>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Create a new instance of a MemoryStore\n */\nconst createMemoryStore = compose<MemoryStoreMixin<Object>, MemoryStoreOptions<Object>>({\n\t\tidProperty: 'id',\n\n\t\tget(id: StoreIndex): MemoryStorePromise<Object> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\treturn wrapResult(store, data && data.get(String(id)));\n\t\t},\n\n\t\tobserve<T>(id?: StoreIndex): Observable<T> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tif (id) {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\tstore.get(String(id)).then((item: T) => {\n\t\t\t\t\t\tif (item) {\n\t\t\t\t\t\t\tobserver.next(item);\n\t\t\t\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\t\t\t\tconst observerArray: Observer<Object>[] = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t\t\t\t\t\t\tobserverArray.push(observer);\n\t\t\t\t\t\t\titemObserverWeakMap.set(store, (observers ? observers : Map<StoreIndex, Observer<Object>[]>()).set(String(id), observerArray));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tobserver.error(new Error(`ID \"${id}\" not found in store`));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\t//\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tput(item: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tconst idProperty = store.idProperty;\n\t\t\tconst id =  options && 'id' in options ? options.id :\n\t\t\t\tidProperty in item ? item[idProperty] :\n\t\t\t\tdata ? data.size : 0;\n\t\t\tif (options && options.replace === false && data && data.has(String(id))) {\n\t\t\t\treturn wrapError(store, Error(`Duplicate ID \"${id}\" when pragma \"replace\" is false`));\n\t\t\t}\n\t\t\titem[idProperty] = id;\n\t\t\tdataWeakMap.set(store, (data ? data : OrderedMap<StoreIndex, Object>()).set(String(id), item));\n\n\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.next(item));\n\t\t\t}\n\t\t\treturn wrapResult(store, item);\n\t\t},\n\n\t\tadd(item: Object, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\treturn this.put(item, assign(options ? options : {}, { replace: false }));\n\t\t},\n\n\t\tpatch(partial: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst idProperty = store.idProperty;\n\t\t\tconst id = options && 'id' in options ? options.id : partial[idProperty];\n\t\t\tif (!id) {\n\t\t\t\treturn wrapError(store, new Error(`Object ID must either be passed in \"partial.${idProperty}\" or \"options.id\"`));\n\t\t\t}\n\t\t\treturn wrapResult(store, store.get(id).then((item) => {\n\t\t\t\tif (item) {\n\t\t\t\t\toptions = options || {};\n\t\t\t\t\toptions.id = id;\n\t\t\t\t\treturn store.put(assign(item, partial), options);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn wrapError(store, new Error(`Object with ID \"${id}\" not found, unable to patch.`));\n\t\t\t\t}\n\t\t\t}));\n\t\t},\n\n\t\tdelete(item: StoreIndex | { [property: string]: number | string; }): MemoryStorePromise<boolean> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\n\t\t\t/**\n\t\t\t * Complete any observers associated with this items id\n\t\t\t */\n\t\t\tfunction completeObservable(id: StoreIndex) {\n\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.complete());\n\t\t\t\t\titemObserverWeakMap.set(store, observers.delete(id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst idProperty = store.idProperty;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tif (typeof item === 'object') {\n\t\t\t\tif (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t\t\t\t\tcompleteObservable(item[idProperty]);\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (data && data.has(String(item))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item)));\n\t\t\t\t\tcompleteObservable(item);\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn wrapResult(store, false);\n\t\t},\n\t\tfromArray(items: Object[]): MemoryStorePromise<void> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst map: Object = {};\n\t\t\tconst idProperty = store.idProperty;\n\t\t\titems.forEach((item: { [prop: string]: StoreIndex }, idx: number) => {\n\t\t\t\tconst id = idProperty in item ? item[idProperty] : idx;\n\t\t\t\titem[idProperty] = id;\n\t\t\t\t(<any> map)[id] = item;\n\t\t\t});\n\t\t\tdataWeakMap.set(store, OrderedMap<StoreIndex, Object>(map));\n\t\t\treturn wrapResult(store, undefined);\n\t\t}\n\t}, (instance, options) => {\n\t\tif (options) {\n\t\t\tif (options.idProperty) {\n\t\t\t\tinstance.idProperty = options.idProperty;\n\t\t\t}\n\t\t\tif (options.data) {\n\t\t\t\tinstance.fromArray(options.data);\n\t\t\t}\n\t\t}\n\t})\n\t.mixin(createDestroyable)\n\t.static({\n\t\tfromArray(data: any[]): MemoryStore<any> {\n\t\t\treturn createMemoryStore({ data });\n\t\t}\n\t}) as MemoryStoreFactory;\n\nexport default createMemoryStore;\n"]}