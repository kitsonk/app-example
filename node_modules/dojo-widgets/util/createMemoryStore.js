(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'immutable/immutable', 'rxjs/Observable', 'dojo-core/lang', 'dojo-core/Promise', 'dojo-core/WeakMap', 'dojo-compose/compose', 'dojo-compose/mixins/createDestroyable'], factory);
    }
})(function (require, exports) {
    "use strict";
    var immutable_1 = require('immutable/immutable');
    var Observable_1 = require('rxjs/Observable');
    var lang_1 = require('dojo-core/lang');
    var Promise_1 = require('dojo-core/Promise');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var compose_1 = require('dojo-compose/compose');
    var createDestroyable_1 = require('dojo-compose/mixins/createDestroyable');
    /**
     * The weak map that contains the data for the stores
     */
    var dataWeakMap = new WeakMap_1.default();
    /**
     * The weak map that contains any observers for the stores
     */
    var itemObserverWeakMap = new WeakMap_1.default();
    /**
     * The methods to decorate the MemoryStorePromise with
     */
    var storeMethods = ['get', 'put', 'add', 'patch', 'delete', 'fromArray'];
    /**
     * Utility function that takes a result and generates a MemoryStorePromise
     * @param store The store to use as a reference when decorating the Promise
     * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created
     */
    function wrapResult(store, result) {
        /* TODO: this all seems pretty expensive, there has to be a better way */
        var p = (Promise_1.isThenable(result) ? result : Promise_1.default.resolve(result));
        storeMethods.forEach(function (method) {
            p[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return p.then(function () {
                    return store[method].apply(store, args);
                });
            };
        });
        return p;
    }
    /**
     * Utility function that takes an error and generates a rejected MemoryStorePromise
     * @param store The store to use as a reference when decorating the Promise
     * @param result The result to wrap
     */
    function wrapError(store, result) {
        var p = (Promise_1.isThenable(result) ? result : Promise_1.default.reject(result));
        storeMethods.forEach(function (method) {
            p[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return p.then(function () {
                    return store[method].apply(store, args);
                });
            };
        });
        return p;
    }
    /**
     * Create a new instance of a MemoryStore
     */
    var createMemoryStore = compose_1.default({
        idProperty: 'id',
        get: function (id) {
            var store = this;
            var data = dataWeakMap.get(store);
            return wrapResult(store, data && data.get(String(id)));
        },
        observe: function (id) {
            var store = this;
            if (id) {
                return new Observable_1.Observable(function subscribe(observer) {
                    store.get(String(id)).then(function (item) {
                        if (item) {
                            observer.next(item);
                            var observers = itemObserverWeakMap.get(store);
                            var observerArray = observers && observers.has(String(id)) ? observers.get(String(id)) : [];
                            observerArray.push(observer);
                            itemObserverWeakMap.set(store, (observers ? observers : immutable_1.Map()).set(String(id), observerArray));
                        }
                        else {
                            observer.error(new Error("ID \"" + id + "\" not found in store"));
                        }
                    });
                });
            }
            else {
                return new Observable_1.Observable(function subscribe(observer) {
                    //
                });
            }
        },
        put: function (item, options) {
            var store = this;
            var data = dataWeakMap.get(store);
            var idProperty = store.idProperty;
            var id = options && 'id' in options ? options.id :
                idProperty in item ? item[idProperty] :
                    data ? data.size : 0;
            if (options && options.replace === false && data && data.has(String(id))) {
                return wrapError(store, Error("Duplicate ID \"" + id + "\" when pragma \"replace\" is false"));
            }
            item[idProperty] = id;
            dataWeakMap.set(store, (data ? data : immutable_1.OrderedMap()).set(String(id), item));
            var observers = itemObserverWeakMap.get(store);
            if (observers && observers.has(String(id))) {
                observers.get(String(id)).forEach(function (observer) { return observer.next(item); });
            }
            return wrapResult(store, item);
        },
        add: function (item, options) {
            return this.put(item, lang_1.assign(options ? options : {}, { replace: false }));
        },
        patch: function (partial, options) {
            var store = this;
            var idProperty = store.idProperty;
            var id = options && 'id' in options ? options.id : partial[idProperty];
            if (!id) {
                return wrapError(store, new Error("Object ID must either be passed in \"partial." + idProperty + "\" or \"options.id\""));
            }
            return wrapResult(store, store.get(id).then(function (item) {
                if (item) {
                    options = options || {};
                    options.id = id;
                    return store.put(lang_1.assign(item, partial), options);
                }
                else {
                    return wrapError(store, new Error("Object with ID \"" + id + "\" not found, unable to patch."));
                }
            }));
        },
        delete: function (item) {
            var store = this;
            /**
             * Complete any observers associated with this items id
             */
            function completeObservable(id) {
                var observers = itemObserverWeakMap.get(store);
                if (observers && observers.has(String(id))) {
                    observers.get(String(id)).forEach(function (observer) { return observer.complete(); });
                    itemObserverWeakMap.set(store, observers.delete(id));
                }
            }
            var idProperty = store.idProperty;
            var data = dataWeakMap.get(store);
            if (typeof item === 'object') {
                if (idProperty in item && data && data.has(String(item[idProperty]))) {
                    dataWeakMap.set(store, data.delete(String(item[idProperty])));
                    completeObservable(item[idProperty]);
                    return wrapResult(store, true);
                }
            }
            else {
                if (data && data.has(String(item))) {
                    dataWeakMap.set(store, data.delete(String(item)));
                    completeObservable(item);
                    return wrapResult(store, true);
                }
            }
            return wrapResult(store, false);
        },
        fromArray: function (items) {
            var store = this;
            var map = {};
            var idProperty = store.idProperty;
            items.forEach(function (item, idx) {
                var id = idProperty in item ? item[idProperty] : idx;
                item[idProperty] = id;
                map[id] = item;
            });
            dataWeakMap.set(store, immutable_1.OrderedMap(map));
            return wrapResult(store, undefined);
        }
    }, function (instance, options) {
        if (options) {
            if (options.idProperty) {
                instance.idProperty = options.idProperty;
            }
            if (options.data) {
                instance.fromArray(options.data);
            }
        }
    })
        .mixin(createDestroyable_1.default)
        .static({
        fromArray: function (data) {
            return createMemoryStore({ data: data });
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createMemoryStore;
});
//# sourceMappingURL=../_debug/util/createMemoryStore.js.map