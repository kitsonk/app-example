(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", './util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min', 'maquette/maquette', 'dojo-compose/compose', 'dojo-core/global', 'dojo-core/lang', 'dojo-core/queue', 'dojo-core/WeakMap', './mixins/createVNodeEvented', './mixins/createParentMixin'], factory);
    }
})(function (require, exports) {
    "use strict";
    require('./util/has!dom-requestanimationframe?:maquette/maquette-polyfills.min'); /* IE9/Node do not support RequestAnimationFrame */
    var maquette_1 = require('maquette/maquette');
    var compose_1 = require('dojo-compose/compose');
    var global_1 = require('dojo-core/global');
    var lang_1 = require('dojo-core/lang');
    var queue_1 = require('dojo-core/queue');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var createVNodeEvented_1 = require('./mixins/createVNodeEvented');
    var createParentMixin_1 = require('./mixins/createParentMixin');
    /* maquette polyfills changed from 2.2 to 2.3 */
    global_1.default.requestAnimationFrame = global_1.default.requestAnimationFrame || global_1.default.window.requestAnimationFrame;
    (function (ProjectorState) {
        ProjectorState[ProjectorState["Attached"] = 1] = "Attached";
        ProjectorState[ProjectorState["Detached"] = 2] = "Detached";
    })(exports.ProjectorState || (exports.ProjectorState = {}));
    var ProjectorState = exports.ProjectorState;
    ;
    var projectorDataMap = new WeakMap_1.default();
    var noopHandle = { destroy: function () { } };
    var emptyVNode = maquette_1.h('div');
    var noopVNode = function () { return emptyVNode; };
    exports.createProjector = compose_1.default({
        getNodeAttributes: function (overrides) {
            /* TODO: This is the same logic as createCachedRenderMixin, merge somehow */
            var projector = this;
            var props = {};
            for (var key in projector.listeners) {
                props[key] = projector.listeners[key];
            }
            var classes = {};
            if (projector.classes) {
                projector.classes.forEach(function (c) { return classes[c] = true; });
            }
            props.classes = classes;
            props.styles = projector.styles || {};
            if (overrides) {
                lang_1.assign(props, overrides);
            }
            return props;
        },
        render: function () {
            var projector = this;
            var projectorData = projectorDataMap.get(projector);
            var childVNodes = [];
            projector.children.forEach(function (child) { return childVNodes.push(child.render()); });
            return maquette_1.h(projectorData.tagName, projector.getNodeAttributes(), childVNodes);
        },
        attach: function (append, tagName) {
            if (append === void 0) { append = false; }
            if (tagName === void 0) { tagName = 'div'; }
            var projector = this;
            var projectorData = projectorDataMap.get(projector);
            if (projectorData.state === ProjectorState.Attached) {
                return projectorData.attachHandle;
            }
            projectorData.boundRender = projector.render.bind(projector);
            projectorData.tagName = tagName;
            /* attaching async, in order to help ensure that if there are any other async behaviours scheduled at the end of the
             * turn, they are executed before this, since the attachement is actually done in turn, but subsequent schedule
             * renders are done out of turn */
            queue_1.queueTask(function () {
                (append ? projectorData.projector.append : projectorData.projector.merge)(projectorData.root, projectorData.boundRender);
            });
            projectorData.state = ProjectorState.Attached;
            projectorData.attachHandle = projector.own({
                destroy: function () {
                    if (projectorData.state === ProjectorState.Attached) {
                        projectorData.projector.stop();
                        try {
                            /* Sometimes Maquette can't seem to find function */
                            projectorData.projector.detach(projectorData.boundRender);
                        }
                        catch (e) {
                            if (e.message !== 'renderMaquetteFunction was not found') {
                                throw e;
                            }
                        }
                        /* for some reason, Maquette still trys to call this in some situations, so the noopVNode is
                         * used to return an empty structure */
                        projectorData.boundRender = noopVNode;
                        projectorData.state = ProjectorState.Detached;
                    }
                    projectorData.attachHandle = noopHandle;
                }
            });
            return projectorData.attachHandle;
        },
        invalidate: function () {
            var projector = this;
            var projectorData = projectorDataMap.get(projector);
            if (projectorData.state === ProjectorState.Attached) {
                projector.emit({
                    type: 'schedulerender',
                    target: projector
                });
                projectorData.projector.scheduleRender();
            }
        },
        setRoot: function (root) {
            var projectorData = projectorDataMap.get(this);
            if (projectorData.state === ProjectorState.Attached) {
                throw new Error('Projector already attached, cannot change root element');
            }
            projectorData.root = root;
        },
        get root() {
            var projectorData = projectorDataMap.get(this);
            return projectorData && projectorData.root;
        },
        get projector() {
            return projectorDataMap.get(this).projector;
        },
        get document() {
            var projectorData = projectorDataMap.get(this);
            return projectorData && projectorData.root && projectorData.root.ownerDocument;
        },
        get state() {
            var projectorData = projectorDataMap.get(this);
            return projectorData && projectorData.state;
        }
    })
        .mixin({
        mixin: createVNodeEvented_1.default,
        initialize: function (instance) {
            /* We have to stub out listeners for Maquette, otherwise it won't allow us to change them down the road */
            instance.on('touchend', function () { });
            instance.on('touchmove', function () { });
        }
    })
        .mixin({
        mixin: createParentMixin_1.default,
        initialize: function (instance, options) {
            var projector = maquette_1.createProjector({});
            var root = options && options.root || document.body;
            projectorDataMap.set(instance, {
                projector: projector,
                root: root,
                state: ProjectorState.Detached
            });
            if (options && options.autoAttach) {
                instance.attach(options && options.append);
            }
        },
        aspectAdvice: {
            after: {
                clear: function () {
                    var projector = this;
                    projector.invalidate();
                }
            }
        }
    });
    var defaultProjector = exports.createProjector();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = defaultProjector;
});
//# sourceMappingURL=projector.js.map