(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'maquette/maquette', 'dojo-compose/mixins/createStateful', 'dojo-core/lang', 'dojo-core/Map', 'dojo-core/WeakMap', './createRenderable', './createVNodeEvented'], factory);
    }
})(function (require, exports) {
    "use strict";
    var maquette_1 = require('maquette/maquette');
    var createStateful_1 = require('dojo-compose/mixins/createStateful');
    var lang_1 = require('dojo-core/lang');
    var Map_1 = require('dojo-core/Map');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var createRenderable_1 = require('./createRenderable');
    var createVNodeEvented_1 = require('./createVNodeEvented');
    /**
     * A map of dirty flags used when determining if the render function
     * should be called
     */
    var dirtyMap = new Map_1.default();
    /**
     * A weak map of the rendered VNode to return when the widget is
     * not dirty.
     */
    var renderCache = new WeakMap_1.default();
    /**
     * A weak map to shadow the classes for the widget
     */
    var shadowClasses = new WeakMap_1.default();
    /**
     * A weak map to shadow the styles for the widget
     */
    var shadowStyles = new WeakMap_1.default();
    var createCachedRenderMixin = createStateful_1.default
        .mixin(createRenderable_1.default)
        .mixin({
        mixin: createVNodeEvented_1.default,
        initialize: function (instance) {
            instance.own(instance.on('statechange', function () { instance.invalidate(); }));
        }
    })
        .mixin({
        mixin: {
            getNodeAttributes: function (overrides) {
                var cachedRender = this;
                var props = cachedRender.state.id ? { 'data-widget-id': cachedRender.state.id } : {};
                for (var key in cachedRender.listeners) {
                    props[key] = cachedRender.listeners[key];
                }
                var classes = {};
                if (cachedRender.classes) {
                    cachedRender.classes.forEach(function (c) { return classes[c] = true; });
                }
                props.classes = classes;
                props.styles = cachedRender.styles || {};
                props.key = cachedRender;
                if (overrides) {
                    lang_1.assign(props, overrides);
                }
                return props;
            },
            getChildrenNodes: function () {
                var cachedRender = this;
                return cachedRender.state.label ? [cachedRender.state.label] : undefined;
            },
            render: function () {
                var cachedRender = this;
                var cached = renderCache.get(cachedRender);
                if (!dirtyMap.get(cachedRender) && cached) {
                    return cached;
                }
                else {
                    cached = maquette_1.h(cachedRender.tagName, cachedRender.getNodeAttributes(), cachedRender.getChildrenNodes());
                    renderCache.set(cachedRender, cached);
                    dirtyMap.set(cachedRender, false);
                    return cached;
                }
            },
            invalidate: function () {
                var cachedRender = this;
                if (dirtyMap.get(cachedRender)) {
                    return;
                }
                var parent = cachedRender.parent;
                dirtyMap.set(cachedRender, true);
                renderCache.delete(cachedRender); /* Allow GC to occur on renderCache */
                if (parent && parent.invalidate) {
                    parent.invalidate();
                }
            },
            get classes() {
                var cachedRender = this;
                return cachedRender.state.classes || shadowClasses.get(cachedRender);
            },
            set classes(value) {
                var cachedRender = this;
                if (cachedRender.state.classes) {
                    cachedRender.setState({ classes: value });
                }
                else {
                    shadowClasses.set(cachedRender, value);
                    cachedRender.invalidate();
                }
            },
            get styles() {
                var cachedRender = this;
                return cachedRender.state.styles || shadowStyles.get(cachedRender);
            },
            set styles(value) {
                var cachedRender = this;
                if (cachedRender.state.styles) {
                    cachedRender.setState({ styles: value });
                }
                else {
                    shadowStyles.set(cachedRender, value);
                    cachedRender.invalidate();
                }
            }
        },
        initialize: function (instance) {
            /* at this point, casting instance as the final type blows up the type inference, so the only choice is to
            * cast as any */
            dirtyMap.set(instance, true);
            shadowClasses.set(instance, []);
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createCachedRenderMixin;
});
//# sourceMappingURL=createCachedRenderMixin.js.map